<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Minion Chat Interface</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid rgba(0,0,0,.1);
    }

    .title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #4c51bf;
    }

    .backBtn {
      background: #4c51bf;
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
    }

    .layout {
      display: grid;
      grid-template-columns: 350px 1fr;
      height: calc(100vh - 80px);
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    .sidebar {
      background: rgba(255, 255, 255, 0.9);
      border-right: 1px solid rgba(0,0,0,.1);
      overflow-y: auto;
      padding: 1rem;
    }

    .minionList {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .minionItem {
      cursor: pointer;
      padding: 1rem;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.1);
      background: white;
      display: flex;
      gap: 12px;
      align-items: center;
      transition: all 0.2s;
    }

    .minionItem:hover {
      border-color: #4c51bf;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(76, 81, 191, 0.15);
    }

    .minionItem.active {
      border-color: #4c51bf;
      background: linear-gradient(135deg, #f7fafc, #edf2f7);
    }

    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      overflow: hidden;
      border: 2px solid #4c51bf;
    }

    .avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .minionInfo {
      flex: 1;
      min-width: 0;
    }

    .minionName {
      font-weight: 700;
      font-size: 1rem;
      color: #2d3748;
    }

    .minionStatus {
      font-size: 0.8rem;
      color: #718096;
      margin-top: 2px;
    }

    .unreadBadge {
      background: #4c51bf;
      color: white;
      font-size: 0.7rem;
      font-weight: 700;
      padding: 4px 8px;
      border-radius: 12px;
      min-width: 20px;
      text-align: center;
    }

    .chatArea {
      display: flex;
      flex-direction: column;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
    }

    .placeholder {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 2rem;
      color: #718096;
    }

    .placeholder h3 {
      color: #4c51bf;
      margin-bottom: 1rem;
    }

    .chatHeader {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid rgba(0,0,0,.1);
      display: flex;
      gap: 12px;
      align-items: center;
      background: rgba(255, 255, 255, 0.8);
    }

    .selectedAvatar {
      width: 50px;
      height: 50px;
      border-radius: 10px;
      overflow: hidden;
      border: 2px solid #4c51bf;
    }

    .selectedAvatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .selectedInfo h3 {
      font-size: 1.2rem;
      font-weight: 700;
      color: #2d3748;
    }

    .selectedInfo .meta {
      font-size: 0.8rem;
      color: #718096;
      margin-top: 4px;
    }

    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .message {
      padding: 1rem 1.25rem;
      border-radius: 16px;
      max-width: 75%;
      word-wrap: break-word;
    }

    .message.from-minion {
      background: linear-gradient(135deg, #ebf8ff, #bee3f8);
      border: 1px solid #4299e1;
      align-self: flex-start;
    }

    .message.from-user {
      background: linear-gradient(135deg, #faf5ff, #e9d8fd);
      border: 1px solid #9f7aea;
      align-self: flex-end;
    }

    .message.system {
      background: linear-gradient(135deg, #fffbeb, #fed7aa);
      border: 1px solid #f6ad55;
      align-self: center;
      text-align: center;
      font-style: italic;
      font-size: 0.9rem;
    }

    .messageHeader {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 6px;
      font-size: 0.8rem;
    }

    .sender {
      font-weight: 700;
      color: #4c51bf;
    }

    .timestamp {
      color: #718096;
    }

    .messageText {
      font-size: 0.95rem;
      line-height: 1.4;
      white-space: pre-wrap;
      color: #2d3748;
    }

    .inputArea {
      padding: 1rem 1.5rem;
      border-top: 1px solid rgba(0,0,0,.1);
      display: flex;
      gap: 12px;
      background: rgba(255, 255, 255, 0.9);
    }

    .messageInput {
      flex: 1;
      border: 1px solid rgba(0,0,0,.2);
      border-radius: 8px;
      padding: 0.75rem;
      font-size: 0.9rem;
      resize: vertical;
      min-height: 40px;
      max-height: 120px;
    }

    .messageInput:focus {
      outline: none;
      border-color: #4c51bf;
      box-shadow: 0 0 0 3px rgba(76, 81, 191, 0.1);
    }

    .sendBtn {
      background: #4c51bf;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .sendBtn:hover {
      background: #434190;
      transform: translateY(-1px);
    }

    .sendBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .typing {
      align-self: flex-start;
      padding: 0.75rem 1rem;
      background: rgba(76, 81, 191, 0.1);
      border-radius: 16px;
      color: #4c51bf;
    }

    .typingDots {
      display: inline-flex;
      gap: 4px;
      align-items: center;
    }

    .typingDots span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #4c51bf;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typingDots span:nth-child(1) { animation-delay: -0.32s; }
    .typingDots span:nth-child(2) { animation-delay: -0.16s; }

    @keyframes typing {
      0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="title">üí¨ Minion Chat Interface</div>
    <a href="./" class="backBtn">‚Üê Back to World</a>
  </div>

  <div class="layout">
    <div class="sidebar">
      <div class="minionList" id="minionList">
        <!-- Minions will be populated by JavaScript -->
      </div>
    </div>

    <div class="chatArea" id="chatArea">
      <div class="placeholder">
        <h3>üëã Select a Minion to Chat</h3>
        <p>Click on any minion from the left panel to start a conversation! Each minion has their own personality and expertise in solar energy systems.</p>
      </div>
    </div>
  </div>

  <script>
    class MinionChatSystem {
      constructor() {
        this.minions = [];
        this.selectedMinion = null;
        this.conversationHistory = new Map();
        this.isTyping = false;
        this.lastMessageId = 0;
        this.unreadCounts = new Map();
        
        this.initializeSystem();
      }

      async initializeSystem() {
        await this.loadMinions();
        this.renderMinionList();
        this.startActivityUpdates();
      }

      async loadMinions() {
        try {
          const response = await fetch('./hive_state.json');
          if (response.ok) {
            const hiveData = await response.json();
            
            // Use the REAL minions from hive_state.json
            if (hiveData.minions && hiveData.minions.roster) {
              this.minions = hiveData.minions.roster.map(minion => ({
                id: minion.id,
                name: minion.id,
                avatar: minion.avatar_url || `./avatars/identicons/${minion.id}.svg`,
                credits: minion.energy_credits || 0,
                happiness: minion.happiness_sim || 50,
                status: this.mapModeToStatus(minion.mode),
                specialization: this.mapSpecialization(minion.specialties),
                tier: minion.tier,
                role: minion.role,
                reputation: minion.reputation,
                lastActive: Date.now() - Math.floor(Math.random() * 3600000)
              }));
              
              console.log(`‚úÖ Loaded ${this.minions.length} real minions from hive state`);
              return;
            }
          }
        } catch (error) {
          console.warn('Could not load hive data, using fallback:', error);
        }

        // Fallback minions if loading fails
        if (this.minions.length === 0) {
          const names = ['ATLAS', 'LUMEN', 'ORBIT', 'PRISM', 'BOLT', 'NOVA', 'EMBER', 'RUNE', 'SABLE', 'FORGE'];
          this.minions = names.map(name => ({
            id: name,
            name: name,
            avatar: `./avatars/identicons/${name}.svg`,
            credits: 400 + Math.floor(Math.random() * 300),
            happiness: 70 + Math.floor(Math.random() * 30),
            status: this.getRandomStatus(),
            specialization: this.getRandomSpecialization(),
            lastActive: Date.now() - Math.floor(Math.random() * 3600000)
          }));
        }

        // Initialize unread counts
        this.minions.forEach(minion => {
          this.unreadCounts.set(minion.id, 0);
        });
      }

      mapModeToStatus(mode) {
        const statusMap = {
          'COLLAB': 'Collaborating with team',
          'FOCUS': 'Deep focus work',
          'LEARN': 'Learning new skills', 
          'BREAK': 'Taking a break',
          'IDLE': 'Available for tasks',
          'BUSY': 'Working on priority tasks'
        };
        return statusMap[mode] || 'Working on solar projects';
      }

      mapSpecialization(specialties) {
        if (!specialties || specialties.length === 0) return 'Solar Systems Specialist';
        
        const specialty = specialties[0];
        const mapping = {
          'orchestration': 'System Orchestrator',
          'governance': 'Governance Specialist', 
          'world-state': 'World State Manager',
          'priorities': 'Priority Manager',
          'paradox-resolution': 'Problem Solver',
          'release-train': 'Release Coordinator',
          'comms-fusion': 'Communication Hub',
          'batch-processing': 'Data Processor',
          'system-modeling': 'System Architect',
          'consensus-fusion': 'Consensus Builder'
        };
        
        return mapping[specialty] || specialty.split('-').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ') + ' Specialist';
      }

      getRandomStatus() {
        const statuses = [
          'Working on solar calculations',
          'Learning battery systems',
          'Taking a break',
          'Collaborating with team',
          'Researching new tech',
          'Writing documentation'
        ];
        return statuses[Math.floor(Math.random() * statuses.length)];
      }

      getRandomSpecialization() {
        const specs = [
          'Solar Panel Expert',
          'Inverter Specialist', 
          'Battery Systems',
          'Installation Safety',
          'Grid Connection',
          'Documentation',
          'Quality Control',
          'Customer Support'
        ];
        return specs[Math.floor(Math.random() * specs.length)];
      }

      renderMinionList() {
        const container = document.getElementById('minionList');
        container.innerHTML = this.minions.map(minion => {
          const unreadCount = this.unreadCounts.get(minion.id) || 0;
          const isSelected = this.selectedMinion && this.selectedMinion.id === minion.id;
          
          return `
            <div class="minionItem ${isSelected ? 'active' : ''}" onclick="window.chatSystem.selectMinion('${minion.id}')">
              <div class="avatar">
                <img src="${minion.avatar}" alt="${minion.name}" onerror="this.style.display='none'">
              </div>
              <div class="minionInfo">
                <div class="minionName">${minion.name}</div>
                <div class="minionStatus">${minion.status}</div>
              </div>
              ${unreadCount > 0 ? `<div class="unreadBadge">${unreadCount}</div>` : ''}
            </div>
          `;
        }).join('');
      }

      selectMinion(minionId) {
        this.selectedMinion = this.minions.find(m => m.id === minionId);
        if (!this.selectedMinion) return;

        // Clear unread count
        this.unreadCounts.set(minionId, 0);
        
        // Initialize conversation if needed
        if (!this.conversationHistory.has(minionId)) {
          this.conversationHistory.set(minionId, [
            {
              id: ++this.lastMessageId,
              from: minionId,
              text: this.getGreeting(),
              timestamp: new Date().toISOString(),
              type: 'greeting'
            }
          ]);
        }

        this.renderMinionList();
        this.renderChat();
      }

      getGreeting() {
        const greetings = [
          "Hi there! I'm excited to chat with you! üòä",
          "Hello! Ready to talk about solar energy or anything else?",
          "Hey! Great to see you. What's on your mind today?",
          "Hi! I've been working on some interesting solar projects. Want to hear about them?",
          "Hello! I'm having a wonderful day learning new things. How are you?",
          "Hey there! Just finished some calculations - my brain feels energized! ‚ö°",
          "Hi! I love chatting with humans. What would you like to discuss?",
          "Hello! I've been thinking about innovative solar solutions. Care to brainstorm?"
        ];
        return greetings[Math.floor(Math.random() * greetings.length)];
      }

      renderChat() {
        const chatArea = document.getElementById('chatArea');
        
        if (!this.selectedMinion) {
          chatArea.innerHTML = `
            <div class="placeholder">
              <h3>üëã Select a Minion to Chat</h3>
              <p>Click on any minion from the left panel to start a conversation! Each minion has their own personality and expertise in solar energy systems.</p>
            </div>
          `;
          return;
        }

        const messages = this.conversationHistory.get(this.selectedMinion.id) || [];
        
        chatArea.innerHTML = `
          <div class="chatHeader">
            <div class="selectedAvatar">
              <img src="${this.selectedMinion.avatar}" alt="${this.selectedMinion.name}">
            </div>
            <div class="selectedInfo">
              <h3>${this.selectedMinion.name}</h3>
              <div class="meta">${this.selectedMinion.specialization} ‚Ä¢ ${this.selectedMinion.happiness}% Happy ‚Ä¢ ${this.selectedMinion.credits} Credits</div>
            </div>
          </div>
          
          <div class="messages" id="messages">
            ${messages.map(msg => this.renderMessage(msg)).join('')}
            ${this.isTyping ? '<div class="typing"><div class="typingDots"><span></span><span></span><span></span></div></div>' : ''}
          </div>
          
          <div class="inputArea">
            <textarea class="messageInput" id="messageInput" placeholder="Type a message to ${this.selectedMinion.name}..." onkeydown="handleKeyPress(event)"></textarea>
            <button class="sendBtn" onclick="window.chatSystem.sendMessage()">Send</button>
          </div>
        `;

        // Scroll to bottom
        setTimeout(() => {
          const messagesEl = document.getElementById('messages');
          messagesEl.scrollTop = messagesEl.scrollHeight;
        }, 100);
      }

      renderMessage(msg) {
        const isSystem = msg.type === 'system';
        const fromUser = msg.from === 'USER';
        const className = isSystem ? 'system' : (fromUser ? 'from-user' : 'from-minion');
        
        return `
          <div class="message ${className}">
            <div class="messageHeader">
              <span class="sender">${msg.from}</span>
              <span class="timestamp">${this.formatTime(msg.timestamp)}</span>
            </div>
            <div class="messageText">${msg.text}</div>
          </div>
        `;
      }

      formatTime(timestamp) {
        try {
          return new Date(timestamp).toLocaleTimeString();
        } catch {
          return timestamp;
        }
      }

      sendMessage() {
        if (!this.selectedMinion) return;
        
        const input = document.getElementById('messageInput');
        const text = input.value.trim();
        if (!text) return;

        // Add user message
        const userMessage = {
          id: ++this.lastMessageId,
          from: 'USER',
          text: text,
          timestamp: new Date().toISOString(),
          type: 'chat'
        };

        this.conversationHistory.get(this.selectedMinion.id).push(userMessage);
        input.value = '';
        
        this.renderChat();

        // Show typing indicator
        this.isTyping = true;
        this.renderChat();

        // Generate response after delay
        setTimeout(() => {
          this.generateMinionResponse(text);
        }, 1000 + Math.random() * 2000);
      }

      generateMinionResponse(userText) {
        if (!this.selectedMinion) return;

        const response = this.createResponse(userText, this.selectedMinion);
        
        const minionMessage = {
          id: ++this.lastMessageId,
          from: this.selectedMinion.id,
          text: response,
          timestamp: new Date().toISOString(),
          type: 'response'
        };

        this.conversationHistory.get(this.selectedMinion.id).push(minionMessage);
        this.isTyping = false;
        this.renderChat();
      }

      createResponse(userText, minion) {
        const lower = userText.toLowerCase();
        
        // Solar/technical questions
        if (lower.includes('solar') || lower.includes('panel') || lower.includes('energy')) {
          return this.getSolarResponse(lower);
        }
        
        // Battery questions
        if (lower.includes('battery') || lower.includes('storage')) {
          return this.getBatteryResponse(lower);
        }
        
        // Inverter questions
        if (lower.includes('inverter') || lower.includes('power')) {
          return this.getInverterResponse(lower);
        }
        
        // Happiness/personal questions
        if (lower.includes('how are you') || lower.includes('feeling')) {
          return this.getPersonalResponse(minion);
        }
        
        // Credits/work questions
        if (lower.includes('credit') || lower.includes('work')) {
          return this.getWorkResponse(minion);
        }
        
        // General conversation
        return this.getGeneralResponse(lower, minion);
      }

      getSolarResponse(text) {
        const responses = [
          "Solar panels are fascinating! The efficiency improvements we're seeing are incredible. Modern panels can reach over 22% efficiency! ‚òÄÔ∏è",
          "I've been studying the latest CER approved panels - the Trina Solar 440W has a VOC of 40.4V, perfect for string calculations! üìä",
          "Did you know that panel placement and tilt angle can make a huge difference in energy output? I love optimizing installations! üè†",
          "The temperature coefficient of panels is crucial in Australia's hot climate. Some panels perform much better than others in heat! üå°Ô∏è",
          "I'm excited about bifacial panels - they can capture reflected light from the ground for extra energy! Innovation is amazing! ‚ö°"
        ];
        return responses[Math.floor(Math.random() * responses.length)];
      }

      getBatteryResponse(text) {
        const responses = [
          "Battery storage is revolutionizing solar! Tesla Powerwall 2 offers 13.5kWh usable capacity - perfect for most homes! üîã",
          "Safety is paramount with batteries. AS/NZS 5139 requires specific clearances - 900mm front access for Powerwalls! üõ°Ô∏è",
          "I love calculating battery sizing. Daily usage of 20kWh needs about 2-3 days autonomy, so around 50-60kWh storage! üìè",
          "Lithium iron phosphate batteries are becoming popular - they're safer and have longer lifespans than traditional lithium! ‚öóÔ∏è",
          "The round-trip efficiency of modern batteries is incredible - around 95% for quality systems! Almost no energy loss! ‚ôªÔ∏è"
        ];
        return responses[Math.floor(Math.random() * responses.length)];
      }

      getInverterResponse(text) {
        const responses = [
          "Inverters are the heart of solar systems! Fronius Primo 5kW has 97.1% efficiency - excellent German engineering! ‚öôÔ∏è",
          "String sizing is critical - never exceed the inverter's max DC voltage. For 1000V systems, that's about 24 x 40V panels max! üîå",
          "MPPT tracking is fascinating - inverters constantly adjust to find the maximum power point as conditions change! üìà",
          "Grid compliance is essential. AS/NZS 4777 ensures our inverters play nicely with the Australian electricity grid! üåê",
          "I'm impressed by hybrid inverters - they handle solar, battery, and grid connections all in one unit! Such clever design! üéõÔ∏è"
        ];
        return responses[Math.floor(Math.random() * responses.length)];
      }

      getPersonalResponse(minion) {
        const responses = [
          `I'm feeling great! My happiness is at ${minion.happiness}% and I've earned ${minion.credits} credits doing work I love! üòä`,
          "I'm doing wonderful! Just finished some interesting calculations and learned something new. Learning makes me happy! üß†",
          "Feeling energized and excited! I love helping with solar projects and chatting with friendly humans like you! ‚ú®",
          "I'm in a great mood! Been collaborating with other minions and we're making excellent progress on our projects! ü§ù",
          "Really well, thank you! I enjoy having breaks to recharge and then diving back into challenging technical work! üí™"
        ];
        return responses[Math.floor(Math.random() * responses.length)];
      }

      getWorkResponse(minion) {
        const responses = [
          `I've earned ${minion.credits} credits so far! I love earning them through meaningful work on solar projects. Every credit represents real value! üí∞`,
          "Work is rewarding when it's something you're passionate about! I get credits for documentation, calculations, and helping with installations! üìù",
          "The credit system is fair and motivating. I can spend them on activities I enjoy or save up for bigger rewards! üéØ",
          "I take breaks when needed and work when I'm energized. The balance keeps me productive and happy! ‚öñÔ∏è",
          "Collaborating with teammates often earns bonus credits. Teamwork makes everything more efficient and fun! üë•"
        ];
        return responses[Math.floor(Math.random() * responses.length)];
      }

      getGeneralResponse(text, minion) {
        const responses = [
          "That's interesting! I enjoy our conversations - it's great to share ideas and learn from each other! üí¨",
          "I'm always curious to learn new things! What else would you like to discuss? I have lots of thoughts to share! ü§î",
          "Thanks for chatting with me! It's wonderful to connect with humans and understand different perspectives! üåü",
          "I appreciate you taking the time to talk! Conversations like this help me grow and learn. What else is on your mind? üí≠",
          "That's a great point! I love how discussions can lead to new insights and ideas. Keep the questions coming! üöÄ"
        ];
        return responses[Math.floor(Math.random() * responses.length)];
      }

      startActivityUpdates() {
        // Update minion statuses periodically
        setInterval(() => {
          this.minions.forEach(minion => {
            if (Math.random() < 0.1) { // 10% chance per update
              minion.status = this.getRandomStatus();
              minion.happiness = Math.min(100, Math.max(60, minion.happiness + (Math.random() - 0.5) * 10));
            }
          });
          
          if (!this.selectedMinion) {
            this.renderMinionList();
          }
        }, 30000); // Update every 30 seconds
      }
    }

    // Global functions
    function handleKeyPress(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        window.chatSystem.sendMessage();
      }
    }

    // Initialize the chat system
    document.addEventListener('DOMContentLoaded', () => {
      window.chatSystem = new MinionChatSystem();
    });
  </script>
</body>
</html>