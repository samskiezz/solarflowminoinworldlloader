<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Minion Control Panel</title>
  <meta name="color-scheme" content="dark" />
  <style>
    :root{--bg1:#070A12;--bg2:#0B1530;--card:rgba(255,255,255,.08);--stroke:rgba(255,255,255,.14);--text:rgba(255,255,255,.92);--muted:rgba(255,255,255,.62);--good:#22c55e;--warn:#f59e0b;--bad:#ef4444;--blue:#60a5fa;--purple:#a78bfa;--cyan:#22d3ee;}
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system;color:var(--text);
      background:radial-gradient(1200px 600px at 10% 10%, rgba(167,139,250,.22), transparent 60%),
               radial-gradient(900px 500px at 85% 20%, rgba(34,211,238,.18), transparent 55%),
               linear-gradient(180deg,var(--bg1),var(--bg2));
      min-height:100vh}

    .header{display:flex;gap:14px;align-items:center;justify-content:space-between;padding:20px;border-bottom:1px solid var(--stroke)}
    .backBtn{cursor:pointer;border:1px solid var(--stroke);background:rgba(255,255,255,.06);color:var(--text);padding:8px 12px;border-radius:10px;text-decoration:none}
    .title{font-size:18px;font-weight:700}
    
    .container{max-width:1200px;margin:0 auto;padding:20px}
    
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin-bottom:24px}
    .controlCard{padding:16px;border-radius:16px;border:1px solid var(--stroke);background:var(--card)}
    .controlTitle{font-size:14px;font-weight:700;margin-bottom:8px}
    .controlBtns{display:flex;gap:8px;flex-wrap:wrap}
    .controlBtn{cursor:pointer;border:1px solid var(--stroke);background:rgba(255,255,255,.06);color:var(--text);padding:8px 12px;border-radius:8px;font-size:12px;transition:all .15s}
    .controlBtn:hover{background:rgba(255,255,255,.1)}
    .controlBtn.danger{background:rgba(239,68,68,.15);border-color:rgba(239,68,68,.5);color:#ff9999}
    .controlBtn.success{background:rgba(34,197,94,.15);border-color:rgba(34,197,94,.5);color:#99ff99}
    
    .minionGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:16px}
    .minionCard{padding:16px;border-radius:16px;border:1px solid var(--stroke);background:var(--card);position:relative}
    .minionCard.offline{opacity:.5;border-color:var(--muted)}
    .minionCard.working{border-color:var(--cyan);box-shadow:0 0 20px rgba(34,211,238,.2)}
    .minionCard.paused{border-color:var(--warn);box-shadow:0 0 20px rgba(245,158,11,.2)}
    
    .minionHeader{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    .minionInfo{display:flex;align-items:center;gap:10px}
    .avatar{width:40px;height:40px;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,.16)}
    .avatar img{width:100%;height:100%;object-fit:cover}
    .minionDetails h3{margin:0;font-size:14px;font-weight:700}
    .minionDetails .meta{font-size:11px;color:var(--muted);margin-top:2px}
    
    .statusBadge{font-size:10px;padding:4px 8px;border-radius:999px;font-weight:600;text-transform:uppercase}
    .statusBadge.active{background:rgba(34,197,94,.2);color:var(--good);border:1px solid rgba(34,197,94,.4)}
    .statusBadge.paused{background:rgba(245,158,11,.2);color:var(--warn);border:1px solid rgba(245,158,11,.4)}
    .statusBadge.offline{background:rgba(148,163,184,.2);color:var(--muted);border:1px solid rgba(148,163,184,.4)}
    
    .minionStats{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:12px 0}
    .stat{text-align:center;padding:8px;border-radius:8px;background:rgba(0,0,0,.2)}
    .statValue{font-size:16px;font-weight:800}
    .statLabel{font-size:10px;color:var(--muted);margin-top:2px}
    
    .progressSection{margin:12px 0}
    .progressLabel{font-size:11px;color:var(--muted);margin-bottom:4px}
    .progressBar{height:6px;border-radius:3px;background:rgba(255,255,255,.1);overflow:hidden}
    .progressFill{height:100%;background:linear-gradient(90deg,var(--cyan),var(--purple));transition:width .3s}
    
    .minionControls{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:12px}
    .minionBtn{cursor:pointer;border:1px solid var(--stroke);background:rgba(255,255,255,.06);color:var(--text);padding:8px;border-radius:6px;font-size:11px;text-align:center;transition:all .15s}
    .minionBtn:hover{background:rgba(255,255,255,.1)}
    .minionBtn.primary{background:rgba(34,211,238,.15);border-color:rgba(34,211,238,.5);color:var(--cyan)}
    .minionBtn.danger{background:rgba(239,68,68,.15);border-color:rgba(239,68,68,.5);color:#ff9999}
    
    .taskAssignment{margin-top:12px;padding:8px;border-radius:8px;background:rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.1)}
    .currentTask{font-size:11px;color:var(--muted);margin-bottom:4px}
    .taskName{font-size:12px;font-weight:600}
    
    .logOutput{margin-top:16px;padding:12px;border-radius:8px;background:rgba(0,0,0,.4);border:1px solid rgba(255,255,255,.1);font-family:Monaco,Consolas,monospace;font-size:11px;max-height:150px;overflow-y:auto}
    .logEntry{margin:2px 0}
    .logEntry.info{color:var(--blue)}
    .logEntry.warn{color:var(--warn)}
    .logEntry.error{color:var(--bad)}
    .logEntry.success{color:var(--good)}
  </style>
</head>
<body>
  <div class="header">
    <a href="./index.html" class="backBtn">‚Üê Back to World</a>
    <div class="title">üéõÔ∏è Minion Control Panel</div>
    <div class="meta">Real-time control interface</div>
  </div>

  <div class="container">
    <div class="controls">
      <div class="controlCard">
        <div class="controlTitle">Global Commands</div>
        <div class="controlBtns">
          <button class="controlBtn success" onclick="globalCommand('start_all')">‚ñ∂ Start All</button>
          <button class="controlBtn" onclick="globalCommand('pause_all')">‚è∏ Pause All</button>
          <button class="controlBtn danger" onclick="globalCommand('emergency_stop')">üõë Emergency Stop</button>
        </div>
      </div>
      
      <div class="controlCard">
        <div class="controlTitle">System Status</div>
        <div id="systemStats">
          <div style="font-size:11px;color:var(--muted)">Loading...</div>
        </div>
      </div>
      
      <div class="controlCard">
        <div class="controlTitle">Task Distribution</div>
        <div class="controlBtns">
          <button class="controlBtn" onclick="redistributeTasks()">üîÑ Redistribute</button>
          <button class="controlBtn" onclick="balanceLoad()">‚öñÔ∏è Balance Load</button>
          <button class="controlBtn" onclick="optimizePerformance()">‚ö° Optimize</button>
        </div>
      </div>
      
      <div class="controlCard">
        <div class="controlTitle">Communication</div>
        <div class="controlBtns">
          <button class="controlBtn" onclick="broadcastMessage()">üì¢ Broadcast</button>
          <button class="controlBtn" onclick="location.href='./minion-chat.html'">üí¨ Open Chat</button>
          <button class="controlBtn" onclick="viewLogs()">üìã View Logs</button>
        </div>
      </div>
    </div>

    <div class="minionGrid" id="minionGrid">
      <!-- Minions will be populated here -->
    </div>

    <div class="logOutput" id="systemLog" style="display:none">
      <div style="font-weight:600;margin-bottom:8px">System Log</div>
      <div id="logEntries"></div>
    </div>
  </div>

  <script>
    let minions = [];
    let systemState = {
      active: 0,
      paused: 0,
      offline: 0,
      totalTasks: 0,
      completedTasks: 0,
      totalCredits: 0
    };
    let logs = [];

    async function loadData() {
      try {
        const [minionsRes] = await Promise.all([
          fetch('./minions.json')
        ]);
        
        const minionsData = await minionsRes.json();
        minions = minionsData.minions || [];
        
        // Initialize minion states
        minions.forEach(minion => {
          if (!minion.controlState) {
            minion.controlState = {
              status: minion.mode === 'active' ? 'active' : 'paused',
              currentTask: `TASK_${minion.id}_${minion.role}`,
              progress: Math.floor(Math.random() * 80) + 10,
              logs: []
            };
          }
        });
        
        updateSystemState();
        renderMinions();
        startPeriodicUpdates();
      } catch (error) {
        addLog('error', `Failed to load data: ${error.message}`);
      }
    }

    function updateSystemState() {
      systemState = {
        active: minions.filter(m => m.controlState?.status === 'active').length,
        paused: minions.filter(m => m.controlState?.status === 'paused').length,
        offline: minions.filter(m => m.controlState?.status === 'offline').length,
        totalTasks: minions.length,
        completedTasks: minions.filter(m => (m.controlState?.progress || 0) >= 100).length,
        totalCredits: minions.reduce((sum, m) => sum + (m.energy_credits || 0), 0)
      };
      
      const statsEl = document.getElementById('systemStats');
      statsEl.innerHTML = `
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;font-size:11px">
          <div>Active: <strong style="color:var(--good)">${systemState.active}</strong></div>
          <div>Paused: <strong style="color:var(--warn)">${systemState.paused}</strong></div>
          <div>Offline: <strong style="color:var(--muted)">${systemState.offline}</strong></div>
          <div>Tasks: <strong>${systemState.completedTasks}/${systemState.totalTasks}</strong></div>
        </div>
      `;
    }

    function renderMinions() {
      const grid = document.getElementById('minionGrid');
      grid.innerHTML = minions.map(minion => renderMinionCard(minion)).join('');
    }

    function renderMinionCard(minion) {
      const state = minion.controlState;
      const statusClass = state.status === 'active' ? 'working' : state.status === 'paused' ? 'paused' : 'offline';
      const progress = state.progress || 0;
      
      return `
        <div class="minionCard ${statusClass}">
          <div class="minionHeader">
            <div class="minionInfo">
              <div class="avatar">
                <img src="${minion.avatar_url}" alt="${minion.id}" onerror="this.style.display='none'">
              </div>
              <div class="minionDetails">
                <h3>${minion.id}</h3>
                <div class="meta">${minion.role} ‚Ä¢ Tier ${minion.tier}</div>
              </div>
            </div>
            <div class="statusBadge ${state.status}">${state.status}</div>
          </div>
          
          <div class="minionStats">
            <div class="stat">
              <div class="statValue">${minion.energy_credits}</div>
              <div class="statLabel">Credits</div>
            </div>
            <div class="stat">
              <div class="statValue">${Math.round(minion.reputation * 100)}</div>
              <div class="statLabel">Rep Score</div>
            </div>
          </div>
          
          <div class="progressSection">
            <div class="progressLabel">Task Progress</div>
            <div class="progressBar">
              <div class="progressFill" style="width:${progress}%"></div>
            </div>
            <div style="font-size:10px;color:var(--muted);margin-top:2px">${progress}% complete</div>
          </div>
          
          <div class="taskAssignment">
            <div class="currentTask">Current Task:</div>
            <div class="taskName">${state.currentTask}</div>
          </div>
          
          <div class="minionControls">
            <button class="minionBtn ${state.status === 'active' ? '' : 'primary'}" onclick="toggleMinionStatus('${minion.id}')">
              ${state.status === 'active' ? '‚è∏ Pause' : '‚ñ∂ Start'}
            </button>
            <button class="minionBtn" onclick="assignTask('${minion.id}')">üìã Assign</button>
            <button class="minionBtn" onclick="location.href='./minion-chat.html?minion=${minion.id}'">üí¨ Chat</button>
            <button class="minionBtn danger" onclick="resetMinion('${minion.id}')">üîÑ Reset</button>
          </div>
          
          ${state.logs && state.logs.length > 0 ? `
            <div class="logOutput">
              ${state.logs.slice(-3).map(log => `<div class="logEntry ${log.type}">[${log.time}] ${log.message}</div>`).join('')}
            </div>
          ` : ''}
        </div>
      `;
    }

    function toggleMinionStatus(minionId) {
      const minion = minions.find(m => m.id === minionId);
      if (!minion) return;
      
      const newStatus = minion.controlState.status === 'active' ? 'paused' : 'active';
      minion.controlState.status = newStatus;
      
      addMinionLog(minionId, 'info', `Status changed to ${newStatus}`);
      addLog('info', `${minionId} ${newStatus === 'active' ? 'resumed' : 'paused'} by user command`);
      
      updateSystemState();
      renderMinions();
    }

    function assignTask(minionId) {
      const taskTypes = [
        'Doc discovery and mapping',
        'PDF verification and validation',
        'Progress monitoring',
        'UI truthfulness audit',
        'System optimization',
        'Canon compliance check',
        'Communication relay',
        'Performance analysis'
      ];
      
      const task = taskTypes[Math.floor(Math.random() * taskTypes.length)];
      const minion = minions.find(m => m.id === minionId);
      if (!minion) return;
      
      minion.controlState.currentTask = task;
      minion.controlState.progress = 0;
      minion.controlState.status = 'active';
      
      addMinionLog(minionId, 'info', `New task assigned: ${task}`);
      addLog('success', `Assigned "${task}" to ${minionId}`);
      
      updateSystemState();
      renderMinions();
    }

    function resetMinion(minionId) {
      if (!confirm(`Reset ${minionId}? This will clear progress and logs.`)) return;
      
      const minion = minions.find(m => m.id === minionId);
      if (!minion) return;
      
      minion.controlState = {
        status: 'paused',
        currentTask: `TASK_${minion.id}_${minion.role}`,
        progress: 0,
        logs: []
      };
      
      addLog('warn', `${minionId} has been reset`);
      
      updateSystemState();
      renderMinions();
    }

    function globalCommand(command) {
      switch(command) {
        case 'start_all':
          minions.forEach(minion => {
            if (minion.controlState.status !== 'active') {
              minion.controlState.status = 'active';
              addMinionLog(minion.id, 'info', 'Started by global command');
            }
          });
          addLog('success', 'All minions started');
          break;
          
        case 'pause_all':
          minions.forEach(minion => {
            if (minion.controlState.status === 'active') {
              minion.controlState.status = 'paused';
              addMinionLog(minion.id, 'info', 'Paused by global command');
            }
          });
          addLog('warn', 'All minions paused');
          break;
          
        case 'emergency_stop':
          if (!confirm('Emergency stop all minions? This will pause all activities immediately.')) return;
          minions.forEach(minion => {
            minion.controlState.status = 'offline';
            addMinionLog(minion.id, 'error', 'Emergency stop activated');
          });
          addLog('error', 'EMERGENCY STOP - All minions offline');
          break;
      }
      
      updateSystemState();
      renderMinions();
    }

    function redistributeTasks() {
      let reassigned = 0;
      minions.forEach(minion => {
        if (Math.random() < 0.3) { // 30% chance of reassignment
          const oldTask = minion.controlState.currentTask;
          assignTask(minion.id);
          reassigned++;
        }
      });
      addLog('info', `Redistributed tasks for ${reassigned} minions`);
    }

    function balanceLoad() {
      // Simulate load balancing by adjusting progress and status
      const overloaded = minions.filter(m => m.controlState.progress > 80);
      const underutilized = minions.filter(m => m.controlState.progress < 20);
      
      overloaded.forEach(minion => {
        minion.controlState.progress = Math.max(20, minion.controlState.progress - 30);
        addMinionLog(minion.id, 'info', 'Load balanced - task redistributed');
      });
      
      addLog('success', `Load balancing completed - adjusted ${overloaded.length} overloaded minions`);
      renderMinions();
    }

    function optimizePerformance() {
      minions.forEach(minion => {
        if (minion.controlState.status === 'active') {
          minion.controlState.progress = Math.min(100, minion.controlState.progress + Math.floor(Math.random() * 15) + 5);
          addMinionLog(minion.id, 'success', 'Performance optimization applied');
        }
      });
      addLog('success', 'Performance optimization completed for all active minions');
      updateSystemState();
      renderMinions();
    }

    function broadcastMessage() {
      const message = prompt('Enter message to broadcast to all minions:');
      if (!message) return;
      
      minions.forEach(minion => {
        addMinionLog(minion.id, 'info', `Broadcast: ${message}`);
      });
      
      addLog('info', `Broadcast sent: "${message}"`);
      renderMinions();
    }

    function viewLogs() {
      const logEl = document.getElementById('systemLog');
      logEl.style.display = logEl.style.display === 'none' ? 'block' : 'none';
      updateLogDisplay();
    }

    function addLog(type, message) {
      const timestamp = new Date().toLocaleTimeString();
      logs.unshift({ type, message, time: timestamp });
      if (logs.length > 50) logs.pop(); // Keep last 50 logs
      updateLogDisplay();
    }

    function addMinionLog(minionId, type, message) {
      const minion = minions.find(m => m.id === minionId);
      if (!minion) return;
      
      const timestamp = new Date().toLocaleTimeString();
      minion.controlState.logs = minion.controlState.logs || [];
      minion.controlState.logs.unshift({ type, message, time: timestamp });
      if (minion.controlState.logs.length > 10) minion.controlState.logs.pop();
    }

    function updateLogDisplay() {
      const logEntriesEl = document.getElementById('logEntries');
      if (logEntriesEl) {
        logEntriesEl.innerHTML = logs.map(log => 
          `<div class="logEntry ${log.type}">[${log.time}] ${log.message}</div>`
        ).join('');
      }
    }

    function startPeriodicUpdates() {
      setInterval(() => {
        // Simulate progress updates for active minions
        minions.forEach(minion => {
          if (minion.controlState.status === 'active' && Math.random() < 0.4) {
            const oldProgress = minion.controlState.progress;
            minion.controlState.progress = Math.min(100, oldProgress + Math.floor(Math.random() * 5) + 1);
            
            if (minion.controlState.progress === 100 && oldProgress < 100) {
              addMinionLog(minion.id, 'success', 'Task completed!');
              // Auto-assign new task
              setTimeout(() => assignTask(minion.id), 2000);
            }
          }
        });
        
        updateSystemState();
        
        // Only re-render if not too frequent
        if (Math.random() < 0.3) {
          renderMinions();
        }
      }, 3000); // Update every 3 seconds
    }

    // Initialize
    loadData();
    addLog('info', 'Minion Control Panel initialized');
  </script>
</body>
</html>