<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate 3D Realm - AI-Integrated Minion Engine</title>
    <script src="./universal-bootloader.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0f1419, #1a1f2e);
            color: white;
            overflow: hidden;
        }
        
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; cursor: crosshair; }
        
        .ui-panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(100, 255, 218, 0.3);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        
        #status {
            top: 20px; left: 20px;
            max-width: 300px;
        }
        
        #chat {
            top: 20px; right: 20px;
            width: 320px; max-height: 400px;
        }
        
        #controls {
            bottom: 20px; left: 20px;
            width: 300px;
        }
        
        .chat-message {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 8px;
            word-wrap: break-word;
        }
        
        .user-message {
            background: rgba(59, 130, 246, 0.3);
            margin-left: 20px;
        }
        
        .ai-message {
            background: rgba(16, 185, 129, 0.3);
            margin-right: 20px;
        }
        
        #chat-messages {
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 12px;
        }
        
        input, button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            margin: 4px;
        }
        
        input {
            width: 100%;
        }
        
        button {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 8px 0;
        }
        
        .status-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }
        
        .error-message {
            background: rgba(239, 68, 68, 0.3);
            color: #fecaca;
            padding: 12px;
            border-radius: 8px;
            margin: 8px 0;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #64ffda;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" class="loading">
            <h2>üöÄ Loading Ultimate 3D Realm...</h2>
            <p>Initializing AI-Integrated Minion Engine</p>
            <div id="load-status">Loading Three.js...</div>
        </div>
    </div>

    <!-- Status Panel -->
    <div id="status" class="ui-panel" style="display: none;">
        <h3>ü§ñ System Status</h3>
        <div class="status-grid">
            <div class="status-item">
                <div>FPS</div>
                <div id="fps">0</div>
            </div>
            <div class="status-item">
                <div>Minions</div>
                <div id="minion-count">0</div>
            </div>
            <div class="status-item">
                <div>Objects</div>
                <div id="object-count">0</div>
            </div>
            <div class="status-item">
                <div>AI Calls</div>
                <div id="ai-calls">0</div>
            </div>
        </div>
        <div>Uptime: <span id="uptime">00:00</span></div>
    </div>

    <!-- AI Chat Panel -->
    <div id="chat" class="ui-panel" style="display: none;">
        <h3>üß† AI Minion Chat</h3>
        <div id="chat-messages">
            <div class="ai-message">Welcome! I can help you communicate with the minions. Try asking about their status! ü§ñ</div>
        </div>
        <input type="text" id="chat-input" placeholder="Talk to the minions..." onkeypress="if(event.key==='Enter') sendMessage()">
        <div>
            <button onclick="sendMessage()">Send</button>
            <button onclick="talkToRandomMinion()">Random Minion</button>
            <button onclick="clearChat()">Clear</button>
        </div>
    </div>

    <!-- Controls Panel -->
    <div id="controls" class="ui-panel" style="display: none;">
        <h3>üéÆ Controls</h3>
        <button onclick="resetCamera()">Reset Camera</button>
        <button onclick="toggleAnimation()">Toggle Animation</button>
        <button onclick="addRandomMinion()">Add Minion</button>
        <button onclick="showHelp()">Help</button>
        <div style="margin-top: 12px; font-size: 12px; opacity: 0.8;">
            WASD: Move camera<br>
            Mouse: Look around<br>
            Space: Focus selected minion<br>
            Click: Select minion
        </div>
    </div>

    <!-- THREE.js - Multiple fallback CDNs -->
    <script>
        console.log('üîÑ Loading Three.js...');
        
        // Try to load Three.js from multiple CDN sources
        function loadThreeJS() {
            return new Promise((resolve, reject) => {
                const sources = [
                    'https://cdnjs.cloudflare.com/ajax/libs/three.js/r150/three.min.js',
                    'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js',
                    'https://unpkg.com/three@0.150.1/build/three.min.js'
                ];
                
                let sourceIndex = 0;
                
                function tryNextSource() {
                    if (sourceIndex >= sources.length) {
                        reject(new Error('All Three.js CDN sources failed'));
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = sources[sourceIndex];
                    
                    script.onload = () => {
                        console.log(`‚úÖ Three.js loaded from: ${sources[sourceIndex]}`);
                        resolve();
                    };
                    
                    script.onerror = () => {
                        console.warn(`‚ùå Failed to load from: ${sources[sourceIndex]}`);
                        sourceIndex++;
                        tryNextSource();
                    };
                    
                    document.head.appendChild(script);
                }
                
                tryNextSource();
            });
        }
        
        // Global variables
        let scene, camera, renderer, raycaster, mouse;
        let minions = [], buildings = [];
        let selectedMinion = null;
        let startTime = Date.now();
        let aiCallCount = 0;
        let animationId = null;
        let animationEnabled = true;
        let lastFrame = Date.now();
        
        // Minion personalities
        const minionPersonalities = {
            'ATLAS': { role: 'Documentation Leader', personality: 'Methodical', mood: 'Focused', color: 0xff6b6b },
            'LUMEN': { role: 'Data Fetcher', personality: 'Quick', mood: 'Energetic', color: 0x4ecdc4 },
            'ORBIT': { role: 'Validator', personality: 'Precise', mood: 'Analytical', color: 0x45b7d1 },
            'PRISM': { role: 'Progress Tracker', personality: 'Reliable', mood: 'Steady', color: 0x96ceb4 },
            'NOVA': { role: 'Innovation Catalyst', personality: 'Creative', mood: 'Inspired', color: 0xffeaa7 },
            'BOLT': { role: 'Speed Optimizer', personality: 'Direct', mood: 'Active', color: 0xfd79a8 }
        };
        
        // Initialize everything
        async function init() {
            try {
                document.getElementById('load-status').textContent = 'Loading Three.js...';
                
                // Load Three.js
                await loadThreeJS();
                
                // Verify THREE.js loaded
                if (typeof THREE === 'undefined') {
                    throw new Error('THREE.js failed to load from all sources');
                }
                
                document.getElementById('load-status').textContent = 'Creating 3D scene...';
                
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0f1419);
                scene.fog = new THREE.Fog(0x0f1419, 50, 200);
                
                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(20, 15, 20);
                camera.lookAt(0, 0, 0);
                
                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.setClearColor(0x0f1419);
                
                // Replace loading with canvas
                const container = document.getElementById('container');
                container.innerHTML = '';
                container.appendChild(renderer.domElement);
                
                document.getElementById('load-status').textContent = 'Setting up lighting...';
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0x64ffda, 0.8);
                directionalLight.position.set(50, 50, 25);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                
                document.getElementById('load-status').textContent = 'Creating environment...';
                
                // Create platform
                const platformGeometry = new THREE.CylinderGeometry(20, 20, 0.5, 32);
                const platformMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1a1f2e,
                    transparent: true,
                    opacity: 0.8 
                });
                const platform = new THREE.Mesh(platformGeometry, platformMaterial);
                platform.position.y = 0.25;
                platform.receiveShadow = true;
                scene.add(platform);
                
                // Create buildings
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = 15;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    const buildingGeometry = new THREE.BoxGeometry(2, 5 + Math.random() * 5, 2);
                    const buildingMaterial = new THREE.MeshPhongMaterial({ 
                        color: new THREE.Color().setHSL(i / 6, 0.7, 0.4)
                    });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    building.position.set(x, building.geometry.parameters.height / 2, z);
                    building.castShadow = true;
                    building.receiveShadow = true;
                    
                    buildings.push(building);
                    scene.add(building);
                }
                
                document.getElementById('load-status').textContent = 'Creating minions...';
                
                // Create minions
                const minionNames = Object.keys(minionPersonalities);
                for (let i = 0; i < minionNames.length; i++) {
                    const name = minionNames[i];
                    const personality = minionPersonalities[name];
                    const angle = (i / minionNames.length) * Math.PI * 2;
                    const radius = 8;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;
                    
                    // Create minion
                    const geometry = new THREE.SphereGeometry(1, 16, 16);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: personality.color,
                        shininess: 100
                    });
                    
                    const minion = new THREE.Mesh(geometry, material);
                    minion.position.set(x, 2, z);
                    minion.castShadow = true;
                    minion.userData = {
                        name: name,
                        role: personality.role,
                        personality: personality.personality,
                        mood: personality.mood,
                        busy: Math.random() > 0.5,
                        lastActivity: Date.now()
                    };
                    
                    minions.push(minion);
                    scene.add(minion);
                    
                    // Create name label
                    createNameLabel(name, x, 4, z);
                }
                
                document.getElementById('load-status').textContent = 'Setting up interactions...';
                
                // Setup interactions
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Mouse events
                renderer.domElement.addEventListener('click', onMouseClick);
                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('resize', onWindowResize);
                
                // Start animation
                startAnimation();
                
                // Show UI panels
                document.getElementById('status').style.display = 'block';
                document.getElementById('chat').style.display = 'block';
                document.getElementById('controls').style.display = 'block';
                
                // Update stats
                document.getElementById('minion-count').textContent = minions.length;
                document.getElementById('object-count').textContent = scene.children.length;
                
                console.log('‚úÖ Ultimate 3D Realm initialized successfully!');
                
            } catch (error) {
                console.error('‚ùå Initialization error:', error);
                showError(`Initialization failed: ${error.message}`);
            }
        }
        
        function createNameLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'Bold 16px Arial';
            context.fillStyle = '#64ffda';
            context.textAlign = 'center';
            context.fillText(text, canvas.width / 2, canvas.height / 2 + 6);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(4, 1, 1);
            
            scene.add(sprite);
        }
        
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(minions);
            
            if (intersects.length > 0) {
                selectedMinion = intersects[0].object;
                console.log('Selected minion:', selectedMinion.userData.name);
                
                // Add chat message
                addChatMessage(`Selected ${selectedMinion.userData.name} - ${selectedMinion.userData.role}`, 'ai');
            }
        }
        
        function onKeyDown(event) {
            const speed = 2;
            switch (event.code) {
                case 'KeyW': camera.position.z -= speed; break;
                case 'KeyS': camera.position.z += speed; break;
                case 'KeyA': camera.position.x -= speed; break;
                case 'KeyD': camera.position.x += speed; break;
                case 'Space': 
                    event.preventDefault();
                    if (selectedMinion) {
                        camera.lookAt(selectedMinion.position);
                    }
                    break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function startAnimation() {
            animate();
            setInterval(updateStats, 1000);
        }
        
        function animate() {
            if (animationEnabled) {
                animationId = requestAnimationFrame(animate);
            }
            
            const time = Date.now() * 0.001;
            
            // Animate minions
            minions.forEach((minion, index) => {
                if (animationEnabled) {
                    minion.rotation.y += 0.02;
                    minion.position.y = 2 + Math.sin(time + index * 2) * 0.3;
                }
                
                // Update activity status
                if (Math.random() < 0.002) {
                    minion.userData.busy = Math.random() > 0.3;
                    minion.userData.lastActivity = Date.now();
                }
            });
            
            // Rotate buildings
            buildings.forEach((building, index) => {
                if (animationEnabled) {
                    building.rotation.y += 0.005;
                }
            });
            
            renderer.render(scene, camera);
        }
        
        function updateStats() {
            const now = Date.now();
            const fps = Math.round(1000 / (now - lastFrame));
            document.getElementById('fps').textContent = fps;
            lastFrame = now;
            
            // Update uptime
            const uptime = Math.floor((now - startTime) / 1000);
            const minutes = Math.floor(uptime / 60);
            const seconds = uptime % 60;
            document.getElementById('uptime').textContent = 
                `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
        }
        
        // AI Chat functions
        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            if (!message) return;
            
            addChatMessage(message, 'user');
            input.value = '';
            
            // Simulate AI response
            aiCallCount++;
            document.getElementById('ai-calls').textContent = aiCallCount;
            
            setTimeout(() => {
                const response = generateAIResponse(message);
                addChatMessage(response, 'ai');
            }, 500 + Math.random() * 1000);
        }
        
        function generateAIResponse(message) {
            if (message.toLowerCase().includes('status')) {
                return `System Status: ${minions.length} minions active, all systems operational! üü¢`;
            } else if (message.toLowerCase().includes('hello') || message.toLowerCase().includes('hi')) {
                return "Hello! I'm the AI controlling the minion realm. How can I help you? ü§ñ";
            } else if (selectedMinion) {
                const minion = selectedMinion.userData;
                return `${minion.name}: "I'm ${minion.mood} and working as ${minion.role}. My personality is ${minion.personality}!" üéØ`;
            } else {
                const responses = [
                    "All minions are working efficiently! üí™",
                    "The 3D realm is running smoothly! ‚ö°",
                    "I'm monitoring all systems. Everything looks good! üåê",
                    "Try clicking on a minion to select them! üéÆ"
                ];
                return responses[Math.floor(Math.random() * responses.length)];
            }
        }
        
        function addChatMessage(text, type) {
            const chatMessages = document.getElementById('chat-messages');
            const div = document.createElement('div');
            div.className = `${type}-message chat-message`;
            div.textContent = text;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function clearChat() {
            const chatMessages = document.getElementById('chat-messages');
            chatMessages.innerHTML = '<div class="ai-message">Chat cleared. How can I help? ü§ñ</div>';
        }
        
        function talkToRandomMinion() {
            const names = Object.keys(minionPersonalities);
            const randomName = names[Math.floor(Math.random() * names.length)];
            const questions = [
                `Hey ${randomName}, what's your status?`,
                `How are you feeling, ${randomName}?`,
                `What's your current mood, ${randomName}?`
            ];
            const question = questions[Math.floor(Math.random() * questions.length)];
            document.getElementById('chat-input').value = question;
            sendMessage();
        }
        
        // Control functions
        function resetCamera() {
            camera.position.set(20, 15, 20);
            camera.lookAt(0, 0, 0);
            console.log('Camera reset');
        }
        
        function toggleAnimation() {
            animationEnabled = !animationEnabled;
            if (animationEnabled) {
                startAnimation();
                console.log('Animation enabled');
            } else {
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                console.log('Animation disabled');
            }
        }
        
        function addRandomMinion() {
            const colors = [0xff9ff3, 0x54a0ff, 0x5f27cd, 0x00d2d3, 0xff9f43, 0x10ac84];
            const names = ['NEW', 'EXTRA', 'BONUS', 'TEMP', 'ADD', 'PLUS'];
            
            const angle = Math.random() * Math.PI * 2;
            const radius = 6 + Math.random() * 4;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const geometry = new THREE.SphereGeometry(0.8, 12, 12);
            const material = new THREE.MeshPhongMaterial({ 
                color: colors[Math.floor(Math.random() * colors.length)]
            });
            
            const minion = new THREE.Mesh(geometry, material);
            minion.position.set(x, 2, z);
            minion.castShadow = true;
            minion.userData = {
                name: names[Math.floor(Math.random() * names.length)] + minions.length,
                role: 'New Worker',
                personality: 'Eager',
                mood: 'Excited',
                busy: false,
                lastActivity: Date.now()
            };
            
            minions.push(minion);
            scene.add(minion);
            
            createNameLabel(minion.userData.name, x, 4, z);
            document.getElementById('minion-count').textContent = minions.length;
            document.getElementById('object-count').textContent = scene.children.length;
            
            console.log('Added new minion:', minion.userData.name);
        }
        
        function showHelp() {
            addChatMessage('Controls: WASD to move camera, Click to select minions, Space to focus on selected minion. Chat with me to interact with the minions! üéÆ', 'ai');
        }
        
        function showError(message) {
            const container = document.getElementById('container');
            container.innerHTML = `
                <div class="error-message">
                    <h2>‚ùå Error</h2>
                    <p>${message}</p>
                    <button onclick="location.reload()">Reload Page</button>
                </div>
            `;
        }
        
        // Start everything when page loads
        document.addEventListener('DOMContentLoaded', init);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        });
    </script>
</body>
</html>