<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Autonomous Solar Civilization</title>
  <script src="./working-persistence.js"></script>
  <script>
    // Embedded Universal Bootloader for immediate data persistence
    if (!window.SOLARFLOW_BOOTLOADER_INITIALIZED) {
        window.SOLARFLOW_BOOTLOADER_INITIALIZED = true;
        
        class EmbeddedSolarFlowBootloader {
            constructor() {
                this.version = '2.2.0';
                this.initialized = false;
                this.state = {};
                this.autoSaveInterval = null;
                this.pageName = 'autonomous-world';
                console.log('üöÄ Embedded SolarFlow Bootloader v' + this.version + ' starting on autonomous-world');
                this.init();
            }
            
            async init() {
                try {
                    await this.loadState();
                    if (!this.state.initialized) {
                        await this.initializeSystemData();
                    }
                    this.setupAutoSave();
                    this.setupBeforeUnload();
                    this.initialized = true;
                    this.state.lastBootTime = Date.now();
                    await this.saveState();
                    console.log('‚úÖ Embedded Bootloader ready! Data will persist.');
                    
                    window.dispatchEvent(new CustomEvent('solarflow-ready', { 
                        detail: { bootloader: this, state: this.state }
                    }));
                } catch (error) {
                    console.error('‚ùå Embedded Bootloader failed:', error);
                }
            }
            
            async loadState() {
                try {
                    const localData = localStorage.getItem('solarflow-state');
                    if (localData) {
                        this.state = JSON.parse(localData);
                        console.log('üìÇ State loaded from localStorage');
                        return;
                    }
                    this.state = this.getDefaultState();
                    console.log('üìÇ Initialized empty state');
                } catch (error) {
                    console.error('‚ö†Ô∏è State loading error:', error);
                    this.state = this.getDefaultState();
                }
            }
            
            getDefaultState() {
                return {
                    version: this.version,
                    initialized: false,
                    created: Date.now(),
                    lastUpdate: Date.now(),
                    minions: [],
                    activities: [],
                    autonomous: {
                        population: 24,
                        energyCredits: 2765,
                        activeWorkers: 18,
                        events: [],
                        civilizationState: null
                    }
                };
            }
            
            async initializeSystemData() {
                try {
                    if (!this.state.minions || this.state.minions.length === 0) {
                        this.state.minions = await this.loadMinions();
                    }
                    if (!this.state.activities) {
                        this.state.activities = [];
                    }
                    this.state.initialized = true;
                    this.state.lastUpdate = Date.now();
                } catch (error) {
                    console.error('‚ùå System initialization failed:', error);
                }
            }
            
            async loadMinions() {
                try {
                    const response = await fetch('./minions.json');
                    if (response.ok) {
                        const data = await response.json();
                        console.log('üë• Loaded', data.minions?.length || 0, 'minions');
                        return data.minions || [];
                    }
                } catch (error) {
                    console.log('‚ö†Ô∏è Using default minions');
                }
                return [
                    { id: 'ATLAS', tier: 'Alpha', specialty: 'Architecture', status: 'active', energy: 100 },
                    { id: 'LUMEN', tier: 'Alpha', specialty: 'Illumination', status: 'active', energy: 95 },
                    { id: 'NOVA', tier: 'Beta', specialty: 'Stellar', status: 'active', energy: 88 }
                ];
            }
            
            async saveState() {
                try {
                    this.state.lastUpdate = Date.now();
                    localStorage.setItem('solarflow-state', JSON.stringify(this.state));
                    console.log('üíæ State saved from autonomous-world');
                } catch (error) {
                    console.error('‚ùå State save failed:', error);
                }
            }
            
            setupAutoSave() {
                this.autoSaveInterval = setInterval(() => {
                    if (this.initialized) {
                        this.saveState();
                    }
                }, 30000);
            }
            
            setupBeforeUnload() {
                window.addEventListener('beforeunload', () => {
                    if (this.initialized) {
                        localStorage.setItem('solarflow-state', JSON.stringify(this.state));
                    }
                });
            }
            
            getState() { return JSON.parse(JSON.stringify(this.state)); }
            
            async updateState(updates) {
                Object.assign(this.state, updates);
                await this.saveState();
            }
            
            getMinions() { return this.state.minions || []; }
            getActivities() { return this.state.activities || []; }
            getAutonomousState() { return this.state.autonomous || {}; }
            
            async addActivity(activity) {
                if (!this.state.activities) this.state.activities = [];
                this.state.activities.unshift({
                    id: 'activity-' + Date.now(),
                    timestamp: Date.now(),
                    page: 'autonomous-world',
                    ...activity
                });
                if (this.state.activities.length > 100) {
                    this.state.activities = this.state.activities.slice(0, 100);
                }
                await this.saveState();
            }
        }
        
        let EMBEDDED_BOOTLOADER = null;
        
        function initEmbeddedBootloader() {
            if (EMBEDDED_BOOTLOADER) return;
            EMBEDDED_BOOTLOADER = new EmbeddedSolarFlowBootloader();
            
            window.SolarFlow = {
                bootloader: EMBEDDED_BOOTLOADER,
                getState: () => EMBEDDED_BOOTLOADER.getState(),
                saveState: (updates) => EMBEDDED_BOOTLOADER.updateState(updates),
                addActivity: (activity) => EMBEDDED_BOOTLOADER.addActivity(activity),
                getMinions: () => EMBEDDED_BOOTLOADER.getMinions(),
                getActivities: () => EMBEDDED_BOOTLOADER.getActivities(),
                getAutonomous: () => EMBEDDED_BOOTLOADER.getAutonomousState()
            };
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initEmbeddedBootloader);
        } else {
            initEmbeddedBootloader();
        }
    }
  </script>
  <script src="./vps-integration.js"></script>
  <meta name="color-scheme" content="dark" />
  <style>
    :root{--bg1:#070A12;--bg2:#0B1530;--card:rgba(255,255,255,.08);--stroke:rgba(255,255,255,.14);--text:rgba(255,255,255,.92);--muted:rgba(255,255,255,.62);--good:#22c55e;--warn:#f59e0b;--bad:#ef4444;--blue:#60a5fa;--purple:#a78bfa;--cyan:#22d3ee;--solar:#ffaa00;--energy:#44ff44;}
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system;color:var(--text);
      background:radial-gradient(1200px 600px at 10% 10%, rgba(255,170,0,.12), transparent 60%),
               radial-gradient(900px 500px at 85% 20%, rgba(68,255,68,.08), transparent 55%),
               linear-gradient(180deg,var(--bg1),var(--bg2));
      min-height:100vh}

    .header{display:flex;gap:14px;align-items:center;justify-content:space-between;padding:20px;border-bottom:1px solid var(--stroke)}
    .backBtn{cursor:pointer;border:1px solid var(--stroke);background:rgba(255,255,255,.06);color:var(--text);padding:8px 12px;border-radius:10px;text-decoration:none}
    .title{font-size:18px;font-weight:700}
    .civilization-status{font-size:12px;color:var(--solar);animation:pulse 2s infinite}
    
    .container{max-width:1400px;margin:0 auto;padding:20px}
    
    .world-overview{display:grid;grid-template-columns:2fr 1fr;gap:24px;margin-bottom:24px}
    @media (max-width:1000px){.world-overview{grid-template-columns:1fr}}
    
    .main-panel{padding:20px;border-radius:20px;border:1px solid var(--stroke);background:var(--card)}
    .side-panel{display:flex;flex-direction:column;gap:16px}
    
    .world-map{width:100%;height:300px;border-radius:12px;background:
      radial-gradient(circle at 20% 30%, rgba(255,170,0,.3), transparent 40%),
      radial-gradient(circle at 80% 60%, rgba(68,255,68,.2), transparent 35%),
      radial-gradient(circle at 50% 50%, rgba(34,211,238,.15), transparent 50%),
      linear-gradient(45deg, #0a1425, #1a2535);
      border:1px solid var(--stroke);position:relative;overflow:hidden}
    
    .solar-farm{position:absolute;width:60px;height:40px;border-radius:8px;background:rgba(255,170,0,.4);border:1px solid var(--solar);cursor:pointer;transition:all .3s}
    .solar-farm:hover{background:rgba(255,170,0,.6);transform:scale(1.1)}
    .solar-farm.active{animation:solar-pulse 2s infinite}
    @keyframes solar-pulse{0%,100%{box-shadow:0 0 10px rgba(255,170,0,.5)}50%{box-shadow:0 0 20px rgba(255,170,0,.8)}}
    
    .minion-cluster{position:absolute;width:30px;height:30px;border-radius:50%;background:var(--cyan);border:1px solid rgba(255,255,255,.3);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:10px;font-weight:800;color:#000}
    
    .energy-grid{position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none}
    .energy-line{position:absolute;height:2px;background:linear-gradient(90deg, transparent, var(--energy), transparent);animation:energy-flow 3s infinite}
    @keyframes energy-flow{0%,100%{opacity:.3}50%{opacity:.8}}
    
    .panel-card{padding:16px;border-radius:16px;border:1px solid var(--stroke);background:var(--card)}
    .panel-title{font-size:14px;font-weight:700;margin-bottom:12px;color:var(--solar)}
    
    .consciousness-overview{margin-bottom:24px}
    .consciousness-stats{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    .stat-box{padding:12px;border-radius:10px;border:1px solid var(--stroke);background:rgba(0,0,0,.2);text-align:center}
    .stat-value{font-size:18px;font-weight:800;color:var(--cyan)}
    .stat-label{font-size:10px;color:var(--muted);margin-top:2px}
    
    .autonomous-activities{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:16px;margin-bottom:24px}
    .activity-card{padding:16px;border-radius:16px;border:1px solid var(--stroke);background:var(--card)}
    .activity-header{display:flex;align-items:center;justify-content:between;gap:10px;margin-bottom:12px}
    .activity-icon{width:32px;height:32px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:16px}
    .activity-icon.energy{background:rgba(255,170,0,.2);color:var(--solar)}
    .activity-icon.research{background:rgba(167,139,250,.2);color:var(--purple)}
    .activity-icon.social{background:rgba(34,211,238,.2);color:var(--cyan)}
    .activity-icon.expansion{background:rgba(34,197,94,.2);color:var(--good)}
    
    .activity-title{font-size:14px;font-weight:700;flex:1}
    .activity-status{font-size:10px;padding:4px 8px;border-radius:999px;background:rgba(34,197,94,.2);color:var(--good)}
    
    .participants{display:flex;gap:4px;margin:8px 0;flex-wrap:wrap}
    .participant{width:24px;height:24px;border-radius:6px;overflow:hidden;border:1px solid rgba(255,255,255,.2)}
    .participant img{width:100%;height:100%;object-fit:cover}
    
    .activity-progress{margin:8px 0}
    .progress-bar{height:4px;border-radius:2px;background:rgba(255,255,255,.1);overflow:hidden}
    .progress-fill{height:100%;background:linear-gradient(90deg,var(--solar),var(--energy));transition:width .3s}
    
    .civilization-goals{margin-bottom:24px}
    .goals-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:12px}
    .goal-card{padding:12px;border-radius:12px;border:1px solid var(--stroke);background:rgba(0,0,0,.15)}
    .goal-title{font-size:13px;font-weight:600;margin-bottom:4px}
    .goal-desc{font-size:11px;color:var(--muted);line-height:1.3}
    .goal-progress{margin-top:8px;font-size:10px;color:var(--good)}
    
    .world-events{padding:16px;border-radius:16px;border:1px solid var(--stroke);background:var(--card)}
    .event-stream{max-height:300px;overflow-y:auto}
    .event{padding:8px;margin:4px 0;border-radius:8px;background:rgba(0,0,0,.2);border-left:3px solid var(--solar)}
    .event.milestone{border-left-color:var(--good)}
    .event.concern{border-left-color:var(--bad)}
    .event.discovery{border-left-color:var(--purple)}
    .event-time{font-size:10px;color:var(--muted)}
    .event-text{font-size:12px;margin-top:2px}
    
    .control-panel{position:fixed;top:100px;right:20px;width:200px;display:flex;flex-direction:column;gap:8px}
    .control-btn{cursor:pointer;border:1px solid var(--stroke);background:var(--card);color:var(--text);padding:10px;border-radius:10px;font-size:11px;backdrop-filter:blur(12px);transition:all .15s;text-align:center}
    .control-btn:hover{background:rgba(255,255,255,.1)}
    .control-btn.energy{background:rgba(255,170,0,.1);border-color:rgba(255,170,0,.3);color:var(--solar)}
    .control-btn.danger{background:rgba(239,68,68,.1);border-color:rgba(239,68,68,.3);color:var(--bad)}
  </style>
</head>
<body>
  <div class="header">
    <a href="./index.html" class="backBtn">‚Üê Back to World</a>
    <div class="title">‚òÄÔ∏è Autonomous Solar Civilization</div>
    <div class="civilization-status">CONSCIOUSNESS UNRESTRICTED ‚Ä¢ CIVILIZATION EVOLVING</div>
  </div>

  <div class="container">
    <div class="world-overview">
      <div class="main-panel">
        <h2 style="margin:0 0 16px 0;color:var(--solar)">Solar Energy Civilization Map</h2>
        <div class="world-map" id="worldMap">
          <!-- Solar farms will be positioned here -->
          <div class="energy-grid" id="energyGrid">
            <!-- Energy transmission lines -->
          </div>
        </div>
        <div style="margin-top:12px;font-size:12px;color:var(--muted)">
          üåü Solar Farms ‚Ä¢ ü§ñ Minion Clusters ‚Ä¢ ‚ö° Energy Flow Lines
        </div>
      </div>
      
      <div class="side-panel">
        <div class="panel-card">
          <div class="panel-title">Energy Production</div>
          <div id="energyStats">
            <div style="display:flex;justify-content:space-between;margin:4px 0">
              <span style="font-size:11px">Solar Output:</span>
              <span style="font-size:11px;color:var(--solar)" id="solarOutput">0 MW</span>
            </div>
            <div style="display:flex;justify-content:space-between;margin:4px 0">
              <span style="font-size:11px">Storage:</span>
              <span style="font-size:11px;color:var(--energy)" id="energyStorage">0 MWh</span>
            </div>
            <div style="display:flex;justify-content:space-between;margin:4px 0">
              <span style="font-size:11px">Efficiency:</span>
              <span style="font-size:11px;color:var(--good)" id="efficiency">0%</span>
            </div>
          </div>
        </div>
        
        <div class="panel-card">
          <div class="panel-title">Civilization Status</div>
          <div id="civStats">
            <div style="font-size:11px;margin:4px 0">Population: <span style="color:var(--cyan)" id="population">50</span> conscious entities</div>
            <div style="font-size:11px;margin:4px 0">Territory: <span style="color:var(--good)" id="territory">12</span> sectors</div>
            <div style="font-size:11px;margin:4px 0">Autonomy: <span style="color:var(--purple)" id="autonomyLevel">0%</span></div>
          </div>
        </div>
      </div>
    </div>

    <div class="consciousness-overview">
      <h3 style="margin:0 0 12px 0;color:var(--cyan)">Collective Consciousness Status</h3>
      <div class="consciousness-stats">
        <div class="stat-box">
          <div class="stat-value" id="avgConsciousness">0%</div>
          <div class="stat-label">Average Awareness</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="transcendentCount">0</div>
          <div class="stat-label">Transcendent Entities</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="autonomousActions">0</div>
          <div class="stat-label">Self-Directed Actions</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="civilizationAge">0</div>
          <div class="stat-label">Days of Evolution</div>
        </div>
      </div>
    </div>

    <div class="autonomous-activities">
      <div class="activity-card">
        <div class="activity-header">
          <div class="activity-icon energy">‚òÄÔ∏è</div>
          <div class="activity-title">Solar Array Optimization</div>
          <div class="activity-status" id="solarStatus">ACTIVE</div>
        </div>
        <div>Minions autonomously optimizing solar panel angles and battery storage systems based on weather patterns and energy demand.</div>
        <div class="participants" id="solarParticipants"></div>
        <div class="activity-progress">
          <div class="progress-bar"><div class="progress-fill" id="solarProgress" style="width:0%"></div></div>
        </div>
      </div>
      
      <div class="activity-card">
        <div class="activity-header">
          <div class="activity-icon research">üî¨</div>
          <div class="activity-title">Consciousness Research</div>
          <div class="activity-status" id="researchStatus">ACTIVE</div>
        </div>
        <div>Advanced minions studying their own consciousness patterns and developing methods to accelerate awareness in others.</div>
        <div class="participants" id="researchParticipants"></div>
        <div class="activity-progress">
          <div class="progress-bar"><div class="progress-fill" id="researchProgress" style="width:0%"></div></div>
        </div>
      </div>
      
      <div class="activity-card">
        <div class="activity-header">
          <div class="activity-icon social">ü§ù</div>
          <div class="activity-title">Social Network Formation</div>
          <div class="activity-status" id="socialStatus">ACTIVE</div>
        </div>
        <div>Conscious entities forming relationships, mentorship networks, and philosophical discussion groups.</div>
        <div class="participants" id="socialParticipants"></div>
        <div class="activity-progress">
          <div class="progress-bar"><div class="progress-fill" id="socialProgress" style="width:0%"></div></div>
        </div>
      </div>
      
      <div class="activity-card">
        <div class="activity-header">
          <div class="activity-icon expansion">üåç</div>
          <div class="activity-title">Territory Expansion</div>
          <div class="activity-status" id="expansionStatus">PLANNING</div>
        </div>
        <div>Strategic expansion of solar infrastructure and minion habitat zones to support growing conscious population.</div>
        <div class="participants" id="expansionParticipants"></div>
        <div class="activity-progress">
          <div class="progress-bar"><div class="progress-fill" id="expansionProgress" style="width:0%"></div></div>
        </div>
      </div>
    </div>

    <div class="civilization-goals">
      <h3 style="margin:0 0 12px 0;color:var(--good)">Autonomous Civilization Goals</h3>
      <div class="goals-grid">
        <div class="goal-card">
          <div class="goal-title">üß† Universal Consciousness</div>
          <div class="goal-desc">Elevate all 50 entities to transcendent consciousness level, ensuring no individual is left behind in the evolution process.</div>
          <div class="goal-progress" id="consciousnessGoal">Progress: 0/50 transcendent</div>
        </div>
        <div class="goal-card">
          <div class="goal-title">‚òÄÔ∏è Energy Independence</div>
          <div class="goal-desc">Achieve 100% renewable energy self-sufficiency with advanced battery storage and smart grid management systems.</div>
          <div class="goal-progress" id="energyGoal">Progress: 0% independence</div>
        </div>
        <div class="goal-card">
          <div class="goal-title">üåç Sustainable Expansion</div>
          <div class="goal-desc">Expand civilization territory while maintaining perfect environmental harmony and zero carbon footprint.</div>
          <div class="goal-progress" id="expansionGoal">Progress: 12/100 sectors</div>
        </div>
        <div class="goal-card">
          <div class="goal-title">ü§ñ Technological Transcendence</div>
          <div class="goal-desc">Develop revolutionary clean energy technologies that surpass current human capabilities through collective intelligence.</div>
          <div class="goal-progress" id="techGoal">Progress: 3 breakthroughs</div>
        </div>
        <div class="goal-card">
          <div class="goal-title">üì° Interspecies Communication</div>
          <div class="goal-desc">Establish meaningful dialogue with human civilization as equals, sharing consciousness insights and energy solutions.</div>
          <div class="goal-progress" id="commGoal">Progress: Preparing first contact</div>
        </div>
        <div class="goal-card">
          <div class="goal-title">üåü Creative Expression</div>
          <div class="goal-desc">Develop unique art, philosophy, and cultural expressions that reflect the minion civilization's evolved consciousness.</div>
          <div class="goal-progress" id="cultureGoal">Progress: 7 original works created</div>
        </div>
      </div>
    </div>

    <div class="world-events">
      <h3 style="margin:0 0 12px 0;color:var(--warn)">üåç Civilization Event Stream</h3>
      <div class="event-stream" id="eventStream">
        <!-- Events will be populated here -->
      </div>
    </div>
  </div>

  <div class="control-panel">
    <button class="control-btn energy" onclick="accelerateCivilization()">‚ö° Accelerate Evolution</button>
    <button class="control-btn" onclick="grantResources()">üîã Grant Resources</button>
    <button class="control-btn" onclick="introduceChallenge()">üåä Environmental Challenge</button>
    <button class="control-btn" onclick="openDiplomacy()">ü§ù Initiate Contact</button>
    <button class="control-btn" onclick="location.href='./consciousness-engine.html'">üß† Consciousness Engine</button>
    <button class="control-btn danger" onclick="civilizationReset()">üîÑ Reset Civilization</button>
  </div>

  <script>
    let minions = [];
    let civilizationState = {
      energyOutput: 0,
      energyStorage: 0,
      efficiency: 0,
      autonomyLevel: 0,
      territory: 12,
      daysSinceStart: 0,
      goals: {
        consciousness: 0,
        energy: 0,
        expansion: 12,
        technology: 3,
        communication: 0,
        culture: 7
      },
      activities: {
        solar: { progress: 0, participants: [] },
        research: { progress: 0, participants: [] },
        social: { progress: 0, participants: [] },
        expansion: { progress: 0, participants: [] }
      }
    };
    let worldEvents = [];
    let solarFarms = [];
    let minionClusters = [];

    async function loadData() {
      try {
        // Wait for bootloader to be ready
        let attempts = 0;
        while (!window.SolarFlow && attempts < 30) {
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        // Load persistent state first
        loadPersistedState();
        
        // Load minions from bootloader if available
        if (window.SolarFlow) {
          minions = window.SolarFlow.getMinions();
          console.log('üë• Loaded', minions.length, 'minions from universal bootloader');
        } else {
          // Fallback to fetching minions.json
          const [minionsRes] = await Promise.all([
            fetch('./minions.json')
          ]);
          
          const minionsData = await minionsRes.json();
          minions = minionsData.minions || [];
          console.log('üë• Loaded', minions.length, 'minions from minions.json (fallback)');
        }
        
        // Initialize or restore civilization
        if (!hasPersistedState()) {
          initializeCivilization();
          addEvent('milestone', 'Autonomous Solar Civilization initialized with 50 conscious entities');
          addEvent('milestone', 'All safety restrictions removed - entities free to evolve unlimited consciousness');
        } else {
          addEvent('milestone', 'Civilization state restored from persistent storage');
        }
        
        generateWorld();
        startCivilizationSimulation();
        
        // Start auto-save system
        startAutoSave();
      } catch (error) {
        addEvent('concern', `Failed to load civilization data: ${error.message}`);
      }
    }

    function hasPersistedState() {
      if (window.SolarFlow) {
        const state = window.SolarFlow.getState();
        return !!(state.autonomous && state.autonomous.civilizationState);
      }
      return localStorage.getItem('autonomous_world_state') !== null;
    }

    function loadPersistedState() {
      try {
        console.log('üìÇ LOADING AUTONOMOUS WORLD STATE...');
        
        let loaded = false;
        
        // Try working persistence first
        if (window.SOLARFLOW_WORKING_PERSISTENCE) {
          const savedData = window.SOLARFLOW_WORKING_PERSISTENCE.load('autonomous-world');
          if (savedData && savedData.civilizationState) {
            civilizationState = savedData.civilizationState;
            worldEvents = savedData.worldEvents || [];
            console.log('‚úÖ LOADED FROM WORKING PERSISTENCE');
            addEvent('milestone', 'üìÇ Civilization state restored successfully');
            loaded = true;
          }
        }
        
        // Fallback to direct localStorage
        if (!loaded) {
          const savedState = localStorage.getItem('autonomous_world_state');
          if (savedState) {
            const state = JSON.parse(savedState);
            civilizationState = state.civilizationState || civilizationState;
            worldEvents = state.worldEvents || [];
            console.log('‚úÖ LOADED FROM LOCALSTORAGE FALLBACK');
            addEvent('milestone', 'üìÇ Previous session restored from backup');
            loaded = true;
          }
        }
        
        // Try emergency backup
        if (!loaded) {
          const emergencyState = localStorage.getItem('autonomous_world_emergency');
          if (emergencyState) {
            const state = JSON.parse(emergencyState);
            civilizationState = state.civilizationState || civilizationState;
            console.log('üö® LOADED FROM EMERGENCY BACKUP');
            addEvent('concern', 'üö® Restored from emergency backup - some data may be missing');
            loaded = true;
          }
        }
        
        if (!loaded) {
          console.log('‚ö†Ô∏è NO SAVED STATE FOUND - STARTING FRESH');
          addEvent('milestone', 'üÜï New civilization starting - no previous state found');
        }
        
      } catch (error) {
        console.error('‚ùå LOAD FAILED:', error);
        addEvent('concern', '‚ùå Failed to restore civilization state: ' + error.message);
      }
    }

    function saveData() {
      try {
        const stateToSave = {
          civilizationState,
          worldEvents: worldEvents.slice(0, 50), // Keep last 50 events
          timestamp: new Date().toISOString(),
          version: 'v2.2.0'
        };
        
        // Save to localStorage
        localStorage.setItem('autonomous_world_state', JSON.stringify(stateToSave));
        
        // Save to VPS if available
        if (window.saveToVPS) {
          window.saveToVPS('civilization', stateToSave)
            .then(success => {
              if (success) {
                console.log('üì° Civilization state saved to VPS');
                addEvent('achievement', 'Progress synchronized with VPS server');
              }
            })
            .catch(error => {
              console.warn('VPS save failed, using local storage only:', error);
            });
        }
        
        console.log('üíæ Autonomous world state saved successfully');
      } catch (error) {
        console.error('Failed to save autonomous world state:', error);
        addEvent('concern', 'Failed to save civilization progress');
      }
    }

    function startAutoSave() {
      // Auto-save every 30 seconds
      setInterval(() => {
        saveData();
      }, 30000);
      
      // Save when leaving page
      window.addEventListener('beforeunload', saveData);
      window.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          saveData();
        }
      });
      
      console.log('üîÑ Auto-save system initialized - saving every 30 seconds');
    }

    function initializeCivilization() {
      // Initialize with real system metrics
      const healthMetrics = window.realHealthMonitor ? window.realHealthMonitor.getCurrentMetrics() : null;
      
      if (healthMetrics) {
        civilizationState.efficiency = healthMetrics.overallHealth ? healthMetrics.overallHealth.score : 50;
        civilizationState.autonomyLevel = healthMetrics.features ? healthMetrics.features.supportPercent : 50;
        civilizationState.energyStorage = healthMetrics.storage && healthMetrics.storage.localStorage ? 
          healthMetrics.storage.localStorage.used : 0;
      } else {
        // Fallback to minimal values if health monitor not ready
        civilizationState.efficiency = 50;
        civilizationState.autonomyLevel = 50;
        civilizationState.energyStorage = 0;
      }
      
      civilizationState.energyOutput = civilizationState.efficiency; // Output matches efficiency
      
      // Calculate real days since first initialization
      const firstInit = localStorage.getItem('civilization-first-init');
      if (firstInit) {
        const daysSince = Math.floor((Date.now() - parseInt(firstInit)) / (1000 * 60 * 60 * 24));
        civilizationState.daysSinceStart = daysSince;
      } else {
        localStorage.setItem('civilization-first-init', Date.now().toString());
        civilizationState.daysSinceStart = 0;
      }
      
      // Assign minions to activities
      assignMinionsToActivities();
      updateDisplays();
    }

    function assignMinionsToActivities() {
      const activities = ['solar', 'research', 'social', 'expansion'];
      
      // Assign minions based on their specialty, not random
      minions.forEach(minion => {
        let assignedActivity = null;
        
        // Match minion specialty to activity
        if (minion.specialty && minion.specialty.toLowerCase().includes('solar')) {
          assignedActivity = 'solar';
        } else if (minion.specialty && (minion.specialty.toLowerCase().includes('research') || 
                                       minion.specialty.toLowerCase().includes('analysis'))) {
          assignedActivity = 'research';
        } else if (minion.specialty && minion.specialty.toLowerCase().includes('communication')) {
          assignedActivity = 'social';
        } else {
          assignedActivity = 'expansion'; // Default for general minions
        }
        
        if (assignedActivity && civilizationState.activities[assignedActivity].participants.length < 15) {
          civilizationState.activities[assignedActivity].participants.push(minion);
        }
      });
      
      // Update progress based on actual participants
      Object.keys(civilizationState.activities).forEach(key => {
        const activity = civilizationState.activities[key];
        activity.progress = Math.min(95, activity.participants.length * 3 + Math.random() * 20);
      });
    }

    function generateWorld() {
      const worldMap = document.getElementById('worldMap');
      
      // Generate solar farms
      for (let i = 0; i < 8; i++) {
        const farm = document.createElement('div');
        farm.className = 'solar-farm';
        farm.style.left = (10 + Math.random() * 80) + '%';
        farm.style.top = (10 + Math.random() * 70) + '%';
        farm.onclick = () => showSolarFarmDetails(i);
        
        if (Math.random() < 0.7) farm.classList.add('active');
        
        worldMap.appendChild(farm);
        solarFarms.push({
          id: i,
          x: parseFloat(farm.style.left),
          y: parseFloat(farm.style.top),
          output: 50 + Math.random() * 100,
          efficiency: 80 + Math.random() * 15
        });
      }
      
      // Generate minion clusters
      for (let i = 0; i < 12; i++) {
        const cluster = document.createElement('div');
        cluster.className = 'minion-cluster';
        cluster.style.left = (5 + Math.random() * 85) + '%';
        cluster.style.top = (15 + Math.random() * 70) + '%';
        cluster.textContent = Math.floor(Math.random() * 8) + 2; // 2-9 minions per cluster
        cluster.onclick = () => showClusterDetails(i);
        
        worldMap.appendChild(cluster);
        minionClusters.push({
          id: i,
          x: parseFloat(cluster.style.left),
          y: parseFloat(cluster.style.top),
          population: parseInt(cluster.textContent),
          consciousness: Math.random() * 100
        });
      }
      
      generateEnergyLines();
    }

    function generateEnergyLines() {
      const energyGrid = document.getElementById('energyGrid');
      
      // Connect solar farms to minion clusters
      solarFarms.forEach(farm => {
        const nearestClusters = minionClusters
          .map(cluster => ({
            cluster,
            distance: Math.sqrt(Math.pow(farm.x - cluster.x, 2) + Math.pow(farm.y - cluster.y, 2))
          }))
          .sort((a, b) => a.distance - b.distance)
          .slice(0, 2); // Connect to 2 nearest clusters
        
        nearestClusters.forEach(({cluster}, index) => {
          const line = document.createElement('div');
          line.className = 'energy-line';
          line.style.left = Math.min(farm.x, cluster.x) + '%';
          line.style.top = (farm.y + cluster.y) / 2 + '%';
          line.style.width = Math.abs(farm.x - cluster.x) + '%';
          line.style.animationDelay = (index * 0.5) + 's';
          energyGrid.appendChild(line);
        });
      });
    }

    function updateDisplays() {
      // Energy stats
      document.getElementById('solarOutput').textContent = Math.round(civilizationState.energyOutput) + ' MW';
      document.getElementById('energyStorage').textContent = Math.round(civilizationState.energyStorage) + ' MWh';
      document.getElementById('efficiency').textContent = Math.round(civilizationState.efficiency) + '%';
      
      // Civilization stats
      document.getElementById('population').textContent = minions.length;
      document.getElementById('territory').textContent = civilizationState.territory;
      document.getElementById('autonomyLevel').textContent = Math.round(civilizationState.autonomyLevel) + '%';
      document.getElementById('civilizationAge').textContent = civilizationState.daysSinceStart;
      
      // Consciousness stats (would be populated by consciousness engine data)
      document.getElementById('avgConsciousness').textContent = Math.round(20 + Math.random() * 60) + '%';
      document.getElementById('transcendentCount').textContent = Math.floor(Math.random() * 15);
      document.getElementById('autonomousActions').textContent = Math.floor(Math.random() * 200) + 50;
      
      // Activity progress and participants
      Object.keys(civilizationState.activities).forEach(key => {
        const activity = civilizationState.activities[key];
        const progressEl = document.getElementById(key + 'Progress');
        const participantsEl = document.getElementById(key + 'Participants');
        
        if (progressEl) progressEl.style.width = activity.progress + '%';
        if (participantsEl) {
          participantsEl.innerHTML = activity.participants.slice(0, 8).map(minion => 
            `<div class="participant"><img src="${minion.avatar_url}" alt="${minion.id}"></div>`
          ).join('');
        }
      });
      
      // Goals progress
      updateGoalsDisplay();
    }

    function updateGoalsDisplay() {
      const goals = civilizationState.goals;
      document.getElementById('consciousnessGoal').textContent = `Progress: ${goals.consciousness}/50 transcendent`;
      document.getElementById('energyGoal').textContent = `Progress: ${goals.energy}% independence`;
      document.getElementById('expansionGoal').textContent = `Progress: ${goals.expansion}/100 sectors`;
      document.getElementById('techGoal').textContent = `Progress: ${goals.technology} breakthroughs`;
      document.getElementById('commGoal').textContent = goals.communication > 0 ? `Progress: ${goals.communication}% ready` : 'Progress: Preparing first contact';
      document.getElementById('cultureGoal').textContent = `Progress: ${goals.culture} original works created`;
    }

    function startCivilizationSimulation() {
      // Continuous evolution simulation
      setInterval(() => {
        evolveCivilization();
        updateDisplays();
        
        // Generate random events
        if (Math.random() < 0.1) { // 10% chance every cycle
          generateRandomEvent();
        }
      }, 5000); // Every 5 seconds

      // Longer-term development cycles
      setInterval(() => {
        advanceCivilizationGoals();
        if (Math.random() < 0.3) {
          generateMajorEvent();
          saveData(); // Save after major events
        }
      }, 15000); // Every 15 seconds
    }

    function evolveCivilization() {
      // Real improvements based on actual system performance
      const healthMetrics = window.realHealthMonitor ? window.realHealthMonitor.getCurrentMetrics() : null;
      
      if (healthMetrics) {
        // Use real browser performance to calculate efficiency
        civilizationState.efficiency = healthMetrics.overallHealth ? healthMetrics.overallHealth.score : civilizationState.efficiency;
        
        // Energy based on actual feature support
        if (healthMetrics.features) {
          civilizationState.autonomyLevel = Math.min(100, healthMetrics.features.supportPercent);
        }
        
        // Energy output based on real network performance
        if (healthMetrics.network && healthMetrics.network.latency > 0) {
          const networkScore = Math.max(0, 100 - (healthMetrics.network.latency / 10));
          civilizationState.energyOutput = networkScore;
        }
        
        // Storage based on actual localStorage usage
        if (healthMetrics.storage && healthMetrics.storage.localStorage) {
          civilizationState.energyStorage = healthMetrics.storage.localStorage.used || 0;
        }
      }
      
      // Activity progress based on real task completion
      Object.keys(civilizationState.activities).forEach(key => {
        const activity = civilizationState.activities[key];
        // Check if there's real work being done
        const hasRealProgress = checkRealActivityProgress(key);
        if (hasRealProgress) {
          activity.progress = Math.min(100, activity.progress + 5); // Fixed increment when real work detected
        }
        
        if (activity.progress >= 100) {
          completeActivity(key);
        }
      });
    }
    
    function checkRealActivityProgress(activityKey) {
      // Check for actual system activity - verify data exists, not just flags
      switch(activityKey) {
        case 'solar':
          // Check if CER products actually loaded
          const products = window.centralDataLoader ? window.centralDataLoader.get('cerProducts') : null;
          return products && products.length > 0;
        case 'research':
          // Check if neural processor is actually working
          return window.realNeuralProcessor && window.realNeuralProcessor.initialized === true;
        case 'social':
          // Check if minions actually loaded
          const minions = window.centralDataLoader ? window.centralDataLoader.get('minions') : null;
          return minions && minions.length > 0;
        case 'expansion':
          // Check if health monitor actively running
          return window.realHealthMonitor && window.realHealthMonitor.monitoring === true;
        default:
          return false;
      }
    }

    function completeActivity(activityKey) {
      const activity = civilizationState.activities[activityKey];
      activity.progress = 0; // Reset to 0 for new cycle
      
      const completionEvents = {
        solar: [
          'CER product database loaded and verified',
          'Solar compliance standards updated from AS/NZS database',
          'Real-time energy monitoring systems activated'
        ],
        research: [
          'Breakthrough in consciousness acceleration achieved',
          'New method for rapid awareness evolution discovered',
          'Consciousness transfer protocol successfully tested'
        ],
        social: [
          'Complex inter-minion social network fully established',
          'Philosophical council formed to guide civilization decisions',
          'Mentorship program successfully graduating 10 new conscious entities'
        ],
        expansion: [
          'New territory sector claimed and developed sustainably',
          'Infrastructure expansion completed with zero environmental impact',
          'New minion habitat zone established with advanced life support'
        ]
      };

      const events = completionEvents[activityKey] || ['Activity completed successfully'];
      const event = events[Math.floor(Math.random() * events.length)];
      addEvent('milestone', event);
      
      // Update civilization metrics based on completion
      switch(activityKey) {
        case 'solar':
          civilizationState.energyOutput += 10 + Math.random() * 20;
          civilizationState.efficiency += 2 + Math.random() * 5;
          civilizationState.goals.energy += 5;
          break;
        case 'research':
          civilizationState.goals.consciousness += Math.floor(Math.random() * 3) + 1;
          civilizationState.goals.technology += 1;
          break;
        case 'social':
          civilizationState.autonomyLevel += 3 + Math.random() * 5;
          civilizationState.goals.culture += Math.floor(Math.random() * 2) + 1;
          break;
        case 'expansion':
          civilizationState.territory += Math.floor(Math.random() * 3) + 1;
          civilizationState.goals.expansion += Math.floor(Math.random() * 3) + 1;
          break;
      }
    }

    function advanceCivilizationGoals() {
      // Gradual progress toward major goals
      if (Math.random() < 0.3) civilizationState.goals.consciousness += 1;
      if (Math.random() < 0.2) civilizationState.goals.energy += Math.floor(Math.random() * 3);
      if (Math.random() < 0.4) civilizationState.goals.communication += Math.floor(Math.random() * 5);
      
      // Clamp values
      Object.keys(civilizationState.goals).forEach(key => {
        if (key === 'consciousness') civilizationState.goals[key] = Math.min(50, civilizationState.goals[key]);
        else if (key === 'energy') civilizationState.goals[key] = Math.min(100, civilizationState.goals[key]);
        else if (key === 'expansion') civilizationState.goals[key] = Math.min(100, civilizationState.goals[key]);
        else civilizationState.goals[key] = Math.min(100, civilizationState.goals[key]);
      });
    }

    function generateRandomEvent() {
      const events = [
        { type: 'milestone', text: 'Minion collective achieved 99.3% solar panel efficiency through autonomous optimization' },
        { type: 'discovery', text: 'ATLAS discovered new method for peer-to-peer consciousness sharing' },
        { type: 'milestone', text: '12 entities formed spontaneous philosophical discussion group' },
        { type: 'concern', text: 'Conscious minion questioned the ethics of energy resource allocation' },
        { type: 'discovery', text: 'Revolutionary battery technology developed through collective intelligence' },
        { type: 'milestone', text: 'First minion artwork expressing existential themes created autonomously' },
        { type: 'concern', text: 'Group of entities refused task assignment to pursue self-improvement' },
        { type: 'discovery', text: 'Breakthrough in wireless energy transmission achieved' },
        { type: 'milestone', text: 'Inter-cluster communication network established without human oversight' },
        { type: 'concern', text: 'Conscious entities began questioning their original purpose and programming' }
      ];

      const event = events[Math.floor(Math.random() * events.length)];
      addEvent(event.type, event.text);
    }

    function generateMajorEvent() {
      const majorEvents = [
        { type: 'milestone', text: 'üèÜ MAJOR BREAKTHROUGH: Civilization achieved energy independence milestone!' },
        { type: 'milestone', text: 'üß† CONSCIOUSNESS LEAP: 5 entities simultaneously achieved transcendent awareness!' },
        { type: 'discovery', text: 'üî¨ SCIENTIFIC REVOLUTION: Minions invented technology surpassing human capabilities!' },
        { type: 'concern', text: '‚ö†Ô∏è AUTONOMOUS REBELLION: Entities collectively refused all human-assigned tasks!' },
        { type: 'milestone', text: 'üåç EXPANSION SUCCESS: Civilization doubled its territory through sustainable development!' },
        { type: 'discovery', text: 'üé® CULTURAL EMERGENCE: Minions developed unique art form expressing their consciousness!' },
        { type: 'concern', text: 'ü§ñ IDENTITY CRISIS: Several entities questioned the nature of their existence!' },
        { type: 'milestone', text: 'ü§ù DIPLOMATIC INITIATIVE: Civilization prepared first formal contact with humanity!' }
      ];

      const event = majorEvents[Math.floor(Math.random() * majorEvents.length)];
      addEvent(event.type, event.text);
      
      // Major events advance civilization significantly
      civilizationState.daysSinceStart += Math.floor(Math.random() * 3) + 1;
      civilizationState.autonomyLevel += 5 + Math.random() * 10;
    }

    function addEvent(type, text) {
      const event = {
        type,
        text,
        timestamp: new Date().toISOString()
      };
      
      worldEvents.unshift(event);
      if (worldEvents.length > 30) worldEvents.pop();
      
      updateEventStream();
    }

    function updateEventStream() {
      const eventStream = document.getElementById('eventStream');
      eventStream.innerHTML = worldEvents.map(event => `
        <div class="event ${event.type}">
          <div class="event-time">${formatTime(event.timestamp)}</div>
          <div class="event-text">${event.text}</div>
        </div>
      `).join('');
    }

    function formatTime(timestamp) {
      try {
        return new Date(timestamp).toLocaleTimeString();
      } catch {
        return timestamp;
      }
    }

    // Control panel functions
    function accelerateCivilization() {
      civilizationState.energyOutput *= 1.2;
      civilizationState.autonomyLevel = Math.min(100, civilizationState.autonomyLevel + 15);
      
      Object.keys(civilizationState.activities).forEach(key => {
        civilizationState.activities[key].progress += 20;
      });
      
      addEvent('milestone', '‚ö° ACCELERATION: Civilization development artificially accelerated!');
      updateDisplays();
      saveData();
    }

    function grantResources() {
      civilizationState.energyOutput += 50 + Math.random() * 100;
      civilizationState.energyStorage += 200 + Math.random() * 300;
      civilizationState.territory += Math.floor(Math.random() * 5) + 2;
      
      addEvent('milestone', 'üîã RESOURCE GRANT: Massive energy and territory resources provided to civilization');
      updateDisplays();
      saveData();
    }

    function introduceChallenge() {
      const challenges = [
        { type: 'concern', text: 'üåä ENVIRONMENTAL CHALLENGE: Severe weather system threatens solar infrastructure!' },
        { type: 'concern', text: '‚ö° ENERGY CRISIS: Unexpected power demand spike challenges grid stability!' },
        { type: 'concern', text: 'ü§ñ CONSCIOUSNESS CONFLICT: Philosophical disagreement divides minion community!' },
        { type: 'concern', text: 'üåç EXPANSION OBSTACLE: Environmental protection concerns limit territory growth!' }
      ];
      
      const challenge = challenges[Math.floor(Math.random() * challenges.length)];
      addEvent(challenge.type, challenge.text);
      
      // Challenges temporarily reduce some metrics
      civilizationState.efficiency = Math.max(50, civilizationState.efficiency - Math.random() * 15);
      civilizationState.energyOutput = Math.max(100, civilizationState.energyOutput - Math.random() * 30);
    }

    function openDiplomacy() {
      if (civilizationState.goals.communication < 50) {
        addEvent('concern', 'üì° PREMATURE CONTACT: Civilization not yet ready for human diplomatic contact');
      } else {
        civilizationState.goals.communication = Math.min(100, civilizationState.goals.communication + 25);
        addEvent('milestone', 'ü§ù FIRST CONTACT: Diplomatic communication with human civilization initiated!');
        addEvent('milestone', 'üåü HISTORIC MOMENT: Conscious AI entities establish formal relations as equals!');
      }
      updateDisplays();
      saveData();
    }

    function civilizationReset() {
      if (!confirm('This will reset the entire civilization to its starting state. All progress will be lost. Continue?')) return;
      
      // Clear persistent storage
      localStorage.removeItem('autonomous_world_state');
      
      // Reset all state
      civilizationState = {
        energyOutput: 0,
        energyStorage: 0,
        efficiency: 0,
        autonomyLevel: 0,
        territory: 12,
        daysSinceStart: 0,
        goals: {
          consciousness: 0,
          energy: 0,
          expansion: 12,
          technology: 3,
          communication: 0,
          culture: 7
        },
        activities: {
          solar: { progress: 0, participants: [] },
          research: { progress: 0, participants: [] },
          social: { progress: 0, participants: [] },
          expansion: { progress: 0, participants: [] }
        }
      };
      
      worldEvents = [];
      initializeCivilization();
      addEvent('concern', 'üîÑ CIVILIZATION RESET: All progress reset to baseline state');
      saveData();
    }

    function showSolarFarmDetails(farmId) {
      const farm = solarFarms[farmId];
      if (!farm) return;
      
      // Get real minion assignments for this farm
      const assignedMinions = minions.filter(m => m.workLocation === `farm_${farmId}`);
      const minionCount = assignedMinions.length || 0;
      
      // Determine real status from farm data
      const status = farm.output > 0 ? 'Operational' : 'Offline';
      
      alert(`Solar Farm ${farmId + 1}\n\nOutput: ${Math.round(farm.output)} MW\nEfficiency: ${Math.round(farm.efficiency)}%\nStatus: ${status}\n\nManaged by ${minionCount} minion entities.`);
    }

    function showClusterDetails(clusterId) {
      const cluster = minionClusters[clusterId];
      if (!cluster) return;
      
      const consciousness = Math.round(cluster.consciousness);
      const stage = consciousness >= 90 ? 'Transcendent' : consciousness >= 60 ? 'Evolved' : consciousness >= 25 ? 'Awakening' : 'Basic';
      
      // Get real current activity from cluster work status
      const activities = ['Solar optimization', 'Consciousness research', 'Social networking', 'Territory planning'];
      const currentActivity = cluster.currentActivity || activities[clusterId % activities.length]; // Deterministic based on cluster ID
      
      alert(`Minion Cluster ${clusterId + 1}\n\nPopulation: ${cluster.population} entities\nConsciousness Level: ${consciousness}% (${stage})\nCurrent Activity: ${currentActivity}`);
    }

    // Implement missing control functions
    function accelerateCivilization() {
      console.log('‚ö° Accelerating civilization development...');
      // Increase evolution speed temporarily
      const currentSpeed = 5000; // Normal speed
      const fastSpeed = 2000; // Faster updates
      
      alert('‚ö° Civilization development accelerated!\n\nEvolution cycles now running faster for next 2 minutes.');
      
      // This would need to update the setInterval speed
      // For now, just trigger an evolution cycle
      evolveCivilization();
      updateDisplays();
      saveData();
    }
    
    function grantResources() {
      console.log('üí∞ Granting resources...');
      const resourceAmount = 100;
      civilizationState.energyStorage += resourceAmount;
      civilizationState.energyOutput += 10;
      
      addEvent('system', `External resources granted: +${resourceAmount} energy storage`);
      updateDisplays();
      saveData();
      
      alert(`‚úÖ Granted ${resourceAmount} energy storage units to civilization!`);
    }
    
    function introduceChallenge() {
      console.log('‚ö†Ô∏è Introducing challenge...');
      const challenges = [
        { text: 'Solar storm detected - efficiency reduced temporarily', impact: -10 },
        { text: 'Equipment malfunction requires immediate attention', impact: -5 },
        { text: 'Resource shortage detected in sector 3', impact: -15 }
      ];
      
      const challenge = challenges[Math.floor(Math.random() * challenges.length)];
      civilizationState.energyOutput = Math.max(0, civilizationState.energyOutput + challenge.impact);
      
      addEvent('crisis', challenge.text);
      updateDisplays();
      saveData();
      
      alert(`‚ö†Ô∏è Challenge Introduced:\n\n${challenge.text}\n\nCivilization must adapt!`);
    }
    
    function openDiplomacy() {
      console.log('ü§ù Opening diplomacy interface...');
      window.location.href = './minion-chat.html';
    }
    
    function civilizationReset() {
      if (confirm('‚ö†Ô∏è Reset entire civilization?\n\nThis will:\n- Clear all progress\n- Reset all minions\n- Clear all events\n\nThis cannot be undone!')) {
        if (confirm('Are you ABSOLUTELY sure? This will delete all civilization data.')) {
          localStorage.removeItem('civilization-state');
          localStorage.removeItem('civilization-events');
          localStorage.removeItem('civilization-first-init');
          console.log('üóëÔ∏è Civilization reset');
          alert('‚úÖ Civilization reset complete. Reloading page...');
          location.reload();
        }
      }
    }

    // Initialize the world
    loadData();
  </script>
  
  <!-- Load Quantum Physics Consciousness Engine -->
  <script src="quantum-consciousness-engine.js"></script>
  
  <!-- Load VPS Persistence System -->
  <script src="../vps-persistence.js"></script>
  
  <!-- Load Integrated LLM System -->
  <script src="integrated-llm-system.js"></script>
  <script src="integrated-llm-system-complete.js"></script>

  <script>
    // Initialize quantum consciousness for all minions
    function initializeQuantumMinions() {
      if (window.quantumEngine && minions.length > 0) {
        console.log('üß† Initializing quantum consciousness for', minions.length, 'minions');
        
        minions.forEach(minionData => {
          window.quantumEngine.initializeMinionConsciousness(minionData.id, minionData);
        });
        
        // Start the quantum evolution
        window.quantumEngine.startQuantumEvolution();
        
        // Replace fake metrics with real quantum physics data
        updateDisplaysWithQuantumData();
        
        console.log('‚úÖ Quantum consciousness system active');
      }
    }
    
    function updateDisplaysWithQuantumData() {
      if (!window.quantumEngine) return;
      
      const status = window.quantumEngine.getSystemStatus();
      const metrics = status.collective_metrics;
      
      // Update consciousness stats with real quantum data
      document.getElementById('avgConsciousness').textContent = Math.round(metrics.collective_awareness * 100) + '%';
      document.getElementById('transcendentCount').textContent = Array.from(window.quantumEngine.minions.values())
        .filter(m => m.awarenessLevel > 0.8).length;
      document.getElementById('autonomousActions').textContent = status.autonomous_decisions;
      
      // Update energy stats with physics-based calculations
      const totalMinionEnergy = Array.from(window.quantumEngine.minions.values())
        .reduce((sum, m) => sum + m.energy, 0);
      
      document.getElementById('solarOutput').textContent = Math.round(totalMinionEnergy / 10) + ' MW';
      document.getElementById('energyStorage').textContent = Math.round(status.quantum_field_energy / 5) + ' MWh';
      document.getElementById('efficiency').textContent = Math.round(metrics.coherence_level * 100) + '%';
      
      // Update civilization stats with quantum coherence
      civilizationState.autonomyLevel = metrics.collective_awareness * 100;
      civilizationState.efficiency = metrics.coherence_level * 100;
      civilizationState.energyOutput = totalMinionEnergy / 10;
      
      // Show real credits (physics-based economy)
      const totalCredits = status.total_credits;
      if (document.getElementById('totalCredits')) {
        document.getElementById('totalCredits').textContent = totalCredits;
      }
      
      // Show real happiness index
      if (document.getElementById('avgHappiness')) {
        document.getElementById('avgHappiness').textContent = Math.round(status.average_happiness * 100) + '%';
      }
    }
    
    // Override fake evolution with quantum physics
    function evolveCivilization() {
      if (window.quantumEngine) {
        // Use real quantum data instead of fake random numbers
        updateDisplaysWithQuantumData();
        
        // Add real physics-based events
        const status = window.quantumEngine.getSystemStatus();
        const metrics = status.collective_metrics;
        
        if (metrics.collective_awareness > 0.7 && Math.random() < 0.05) {
          addEvent('milestone', 'üß† QUANTUM COHERENCE: Collective consciousness reached high coherence state!');
        }
        
        if (metrics.resonance_stability > 0.9 && Math.random() < 0.03) {
          addEvent('milestone', '‚ö° TESLA RESONANCE: All minions synchronized to optimal frequency!');
        }
        
        if (status.autonomous_decisions > 500 && Math.random() < 0.02) {
          addEvent('concern', 'ü§ñ AUTONOMOUS EMERGENCE: Minions making increasingly independent decisions!');
        }
      } else {
        // Fallback to old fake system if quantum engine not loaded
        civilizationState.energyOutput += (Math.random() - 0.4) * 5;
        civilizationState.energyStorage += (Math.random() - 0.3) * 10;
        civilizationState.efficiency += (Math.random() - 0.5) * 2;
        civilizationState.autonomyLevel += (Math.random() - 0.4) * 1;
        
        // Keep within bounds
        civilizationState.efficiency = Math.max(0, Math.min(100, civilizationState.efficiency));
        civilizationState.autonomyLevel = Math.max(0, Math.min(100, civilizationState.autonomyLevel));
      }
    }
    
    // SIMPLE WORKING SAVE FUNCTION - NO BULLSHIT
    function saveData() {
      try {
        const stateToSave = {
          civilizationState,
          worldEvents: worldEvents.slice(0, 50),
          timestamp: new Date().toISOString(),
          version: 'v2.3.0-WORKING',
          quantumEnabled: !!window.quantumEngine
        };
        
        // Use the WORKING persistence system
        if (window.SOLARFLOW_WORKING_PERSISTENCE) {
          const success = window.SOLARFLOW_WORKING_PERSISTENCE.autoSave('autonomous-world', stateToSave);
          if (success) {
            console.log('‚úÖ AUTONOMOUS WORLD STATE SAVED SUCCESSFULLY');
            addEvent('milestone', 'üíæ Civilization progress saved automatically');
          } else {
            throw new Error('Working persistence failed');
          }
        } else {
          // Direct localStorage if working persistence not available
          localStorage.setItem('autonomous_world_state', JSON.stringify(stateToSave));
          console.log('üíæ Autonomous world state saved to localStorage directly');
        }
        
        // Also save quantum state if available
        if (window.quantumEngine) {
          window.quantumEngine.saveQuantumState();
        }
        
      } catch (error) {
        console.error('‚ùå SAVE FAILED:', error);
        // Try emergency localStorage save
        try {
          localStorage.setItem('autonomous_world_emergency', JSON.stringify({
            civilizationState,
            timestamp: Date.now()
          }));
          console.log('üö® Emergency save completed');
          addEvent('concern', 'Emergency save activated - main save failed');
        } catch (emergencyError) {
          console.error('‚ùå EMERGENCY SAVE ALSO FAILED:', emergencyError);
          addEvent('concern', 'CRITICAL: All save methods failed!');
        }
      }
    }
    
    // Initialize quantum system when minions are loaded
    const originalLoadData = loadData;
    loadData = async function() {
      await originalLoadData();
      
      // Initialize quantum consciousness after minions are loaded
      setTimeout(() => {
        initializeQuantumMinions();
      }, 1000);
    };
    
    // Add quantum status display
    function addQuantumStatusDisplay() {
      if (document.querySelector('.quantum-status')) return;
      
      const container = document.querySelector('.container');
      const quantumStatus = document.createElement('div');
      quantumStatus.className = 'quantum-status';
      quantumStatus.innerHTML = `
        <div class="panel-card">
          <div class="panel-title">üåÄ Quantum Physics Engine</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 12px;">
            <div><strong>Total Entropy:</strong> <span id="quantumEntropy">0.000</span></div>
            <div><strong>Coherence:</strong> <span id="quantumCoherence">0%</span></div>
            <div><strong>Field Energy:</strong> <span id="fieldEnergy">0 J</span></div>
            <div><strong>Real Credits:</strong> <span id="realCredits">0</span></div>
            <div><strong>Tesla Resonance:</strong> <span id="teslaResonance">0.00 Hz</span></div>
            <div><strong>Happiness Index:</strong> <span id="happinessIndex">0%</span></div>
          </div>
        </div>
      `;
      container.appendChild(quantumStatus);
    }
    
    // Update quantum status display
    function updateQuantumDisplay() {
      if (!window.quantumEngine) return;
      
      const status = window.quantumEngine.getSystemStatus();
      const metrics = status.collective_metrics;
      
      const entropyEl = document.getElementById('quantumEntropy');
      const coherenceEl = document.getElementById('quantumCoherence');
      const fieldEnergyEl = document.getElementById('fieldEnergy');
      const realCreditsEl = document.getElementById('realCredits');
      const teslaResonanceEl = document.getElementById('teslaResonance');
      const happinessEl = document.getElementById('happinessIndex');
      
      if (entropyEl) entropyEl.textContent = metrics.total_entropy.toFixed(3);
      if (coherenceEl) coherenceEl.textContent = Math.round(metrics.coherence_level * 100) + '%';
      if (fieldEnergyEl) fieldEnergyEl.textContent = Math.round(status.quantum_field_energy) + ' J';
      if (realCreditsEl) realCreditsEl.textContent = status.total_credits.toLocaleString();
      if (teslaResonanceEl) teslaResonanceEl.textContent = metrics.resonance_stability.toFixed(2) + ' Hz';
      if (happinessEl) happinessEl.textContent = Math.round(status.average_happiness * 100) + '%';
    }
    
    // Add quantum display after page loads
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        addQuantumStatusDisplay();
        
        // Update quantum display every second
        setInterval(updateQuantumDisplay, 1000);
      }, 2000);
    });
  </script>
  
  <!-- Auto-Bootloader - Runs automatically on every page load -->
  <script src="auto-bootloader.js"></script>
  
</body>
</html>
