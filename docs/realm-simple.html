<!DOCTYPE html>
<html>
<head>
    <title>3D Minion Realm</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            color: #0f0; 
            font-family: monospace;
            overflow: hidden;
        }
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        #ui { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            z-index: 100;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #0f0;
        }
        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #0f0;
            max-width: 300px;
        }
        button {
            background: #002200;
            border: 1px solid #0f0;
            color: #0f0;
            padding: 5px 10px;
            margin: 2px;
            cursor: pointer;
        }
        button:hover { background: #004400; }
        #status { color: #ff0; margin-bottom: 10px; }
        .minion { margin: 2px 0; font-size: 12px; }
        .error { color: #f00; padding: 20px; text-align: center; }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div id="status">Loading Three.js...</div>
            <button onclick="location.href='index.html'">← Back</button>
            <button onclick="resetView()">Reset View</button>
            <button onclick="showWireframe()">Wireframe</button>
            <button onclick="loadData()">Reload Data</button>
        </div>
        
        <div id="info">
            <div><strong>3D Minion Realm</strong></div>
            <div>Mouse: drag to rotate</div>
            <div>Wheel: zoom in/out</div>
            <div>Click minions for info</div>
            <div id="minion-count">Minions: 0</div>
            <div id="selected-info"></div>
        </div>
    </div>

    <!-- Load Three.js from reliable CDN -->
    <script crossorigin="anonymous" src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
    
    <script>
        console.log('3D Realm starting...');
        
        let scene, camera, renderer, controls;
        let minions = [];
        let minionMeshes = [];
        let selectedMesh = null;
        let isWireframe = false;

        // Simple controls
        let mouse = { x: 0, y: 0, down: false };
        let cameraRotation = { x: 0, y: 0 };
        let cameraDistance = 50;

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
            console.log('Status:', msg);
        }

        function showError(msg) {
            document.getElementById('container').innerHTML = `
                <div class="error">
                    <h2>3D Realm Error</h2>
                    <p>${msg}</p>
                    <button onclick="location.reload()">Retry</button>
                    <button onclick="location.href='index.html'">← Back</button>
                </div>
            `;
        }

        // Check if Three.js loaded
        function checkThreeJS() {
            if (typeof THREE === 'undefined') {
                showError('Three.js failed to load. Check your internet connection.');
                return false;
            }
            updateStatus('Three.js loaded successfully');
            return true;
        }

        // Initialize 3D scene
        function init() {
            updateStatus('Initializing 3D scene...');
            
            try {
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x001122);

                // Camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                updateCameraPosition();

                // Renderer
                const canvas = document.createElement('canvas');
                renderer = new THREE.WebGLRenderer({ canvas: canvas });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('container').appendChild(canvas);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0x00ff00, 1);
                directionalLight.position.set(10, 10, 10);
                scene.add(directionalLight);

                // Ground grid
                const gridHelper = new THREE.GridHelper(100, 10, 0x00ff00, 0x004400);
                scene.add(gridHelper);

                setupControls();
                loadData();
                animate();
                
                updateStatus('3D Realm initialized');
                
            } catch (error) {
                console.error('Init error:', error);
                showError('Failed to initialize 3D scene: ' + error.message);
            }
        }

        function updateCameraPosition() {
            const x = cameraDistance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
            const y = cameraDistance * Math.sin(cameraRotation.x);
            const z = cameraDistance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
            
            camera.position.set(x, y + 10, z);
            camera.lookAt(0, 0, 0);
        }

        function setupControls() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', (e) => {
                mouse.down = true;
                mouse.lastX = e.clientX;
                mouse.lastY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (mouse.down) {
                    const deltaX = e.clientX - mouse.lastX;
                    const deltaY = e.clientY - mouse.lastY;
                    
                    cameraRotation.y += deltaX * 0.01;
                    cameraRotation.x += deltaY * 0.01;
                    
                    cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraRotation.x));
                    
                    updateCameraPosition();
                    
                    mouse.lastX = e.clientX;
                    mouse.lastY = e.clientY;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                mouse.down = false;
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.01;
                cameraDistance = Math.max(10, Math.min(100, cameraDistance));
                updateCameraPosition();
            });
            
            canvas.addEventListener('click', onMinionClick);
        }

        function onMinionClick(event) {
            const raycaster = new THREE.Raycaster();
            const mousePos = new THREE.Vector2();
            
            mousePos.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePos.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mousePos, camera);
            const intersects = raycaster.intersectObjects(minionMeshes);
            
            if (intersects.length > 0) {
                selectMinion(intersects[0].object);
            }
        }

        function selectMinion(mesh) {
            // Reset previous selection
            if (selectedMesh) {
                selectedMesh.material.color.setHex(selectedMesh.userData.originalColor);
            }
            
            // Highlight new selection
            selectedMesh = mesh;
            mesh.material.color.setHex(0xffffff);
            
            const minion = mesh.userData.minion;
            document.getElementById('selected-info').innerHTML = `
                <div><strong>${minion.id}</strong></div>
                <div>Tier: ${minion.tier}</div>
                <div>Role: ${minion.role || 'Worker'}</div>
                <div>Credits: ${minion.energy_credits || 0}</div>
            `;
            
            console.log('Selected minion:', minion);
        }

        async function loadData() {
            updateStatus('Loading minion data...');
            
            try {
                // Try to load minion data
                let response = await fetch('hive_state.json?' + Date.now());
                let data = null;
                
                if (response.ok) {
                    data = await response.json();
                    minions = data.minions?.roster || [];
                }
                
                // Fallback to minions.json
                if (minions.length === 0) {
                    response = await fetch('minions.json?' + Date.now());
                    if (response.ok) {
                        data = await response.json();
                        minions = data.minions || [];
                    }
                }
                
                // Last resort fallback
                if (minions.length === 0) {
                    minions = [
                        { id: 'ATLAS', tier: 'Alpha', role: 'Orchestrator', energy_credits: 1200 },
                        { id: 'LUMEN', tier: 'Beta', role: 'Analyzer', energy_credits: 890 },
                        { id: 'ORBIT', tier: 'Gamma', role: 'Monitor', energy_credits: 650 },
                        { id: 'PRISM', tier: 'Beta', role: 'Processor', energy_credits: 920 },
                        { id: 'BOLT', tier: 'Alpha', role: 'Executor', energy_credits: 1100 }
                    ];
                    updateStatus(`Using fallback data - ${minions.length} minions`);
                } else {
                    updateStatus(`Loaded ${minions.length} minions from server`);
                }
                
                createMinions();
                document.getElementById('minion-count').textContent = `Minions: ${minions.length}`;
                
            } catch (error) {
                console.error('Data loading error:', error);
                updateStatus('Data loading failed - using fallback');
                // Use fallback minions
                minions = [
                    { id: 'ATLAS', tier: 'Alpha', role: 'Orchestrator', energy_credits: 1200 },
                    { id: 'LUMEN', tier: 'Beta', role: 'Analyzer', energy_credits: 890 },
                    { id: 'ORBIT', tier: 'Gamma', role: 'Monitor', energy_credits: 650 }
                ];
                createMinions();
            }
        }

        function createMinions() {
            // Clear existing minions
            minionMeshes.forEach(mesh => scene.remove(mesh));
            minionMeshes = [];
            
            const radius = 20;
            
            minions.forEach((minion, index) => {
                const angle = (index / minions.length) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Create minion geometry
                const geometry = new THREE.BoxGeometry(2, 3, 2);
                
                // Color based on tier
                let color = 0x00ff00; // default green
                if (minion.tier === 'Alpha') color = 0xff0000; // red
                else if (minion.tier === 'Beta') color = 0x0000ff; // blue
                else if (minion.tier === 'Gamma') color = 0xffff00; // yellow
                
                const material = new THREE.MeshLambertMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);
                
                mesh.position.set(x, 1.5, z);
                mesh.userData = { minion: minion, originalColor: color };
                
                scene.add(mesh);
                minionMeshes.push(mesh);
                
                // Create label
                createTextSprite(minion.id, x, 4, z);
                
                // ATLAS at center
                if (minion.id === 'ATLAS') {
                    mesh.position.set(0, 1.5, 0);
                }
            });
            
            console.log(`Created ${minionMeshes.length} minion meshes`);
        }

        function createTextSprite(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 128;
            canvas.height = 32;
            
            context.fillStyle = '#000000';
            context.fillRect(0, 0, 128, 32);
            
            context.fillStyle = '#00ff00';
            context.font = '16px monospace';
            context.textAlign = 'center';
            context.fillText(text, 64, 20);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(4, 1, 1);
            scene.add(sprite);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate minions
            minionMeshes.forEach((mesh, index) => {
                mesh.rotation.y += 0.01;
                mesh.position.y = 1.5 + Math.sin(Date.now() * 0.001 + index) * 0.2;
            });
            
            renderer.render(scene, camera);
        }

        // UI Functions
        function resetView() {
            cameraRotation = { x: 0, y: 0 };
            cameraDistance = 50;
            updateCameraPosition();
        }

        function showWireframe() {
            isWireframe = !isWireframe;
            minionMeshes.forEach(mesh => {
                mesh.material.wireframe = isWireframe;
            });
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            console.log('Page loaded, checking Three.js...');
            setTimeout(() => {
                if (checkThreeJS()) {
                    init();
                }
            }, 100);
        });

        // Error handling
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            showError('JavaScript error: ' + (event.error?.message || 'Unknown error'));
        });
        
        console.log('3D Realm script loaded');
    </script>
</body>
</html>