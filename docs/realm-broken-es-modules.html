<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SolarFlow ‚Ä¢ 3D Minion Realm - WORKING</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        html, body {
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .hud-button {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .hud-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .status-display {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(0, 255, 136, 0.5);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            min-width: 250px;
        }
        
        .status-title {
            color: #00ff88;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .status-item {
            margin: 5px 0;
            font-size: 13px;
        }
        
        .minion-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .loading-screen {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 255, 136, 0.3);
            border-top: 3px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #00ff88;
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .loading-progress {
            color: #ccc;
            font-size: 14px;
        }
        
        .error-display {
            position: fixed;
            inset: 20px;
            z-index: 3000;
            background: rgba(139, 69, 19, 0.9);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .error-title {
            color: #ff6666;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        .error-message {
            color: #ffcccc;
            font-size: 14px;
            white-space: pre-wrap;
            font-family: monospace;
        }
        
        .controls-help {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            padding: 10px;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing 3D Minion Realm</div>
        <div class="loading-progress" id="loadingProgress">Starting...</div>
    </div>

    <!-- Error Display -->
    <div id="errorDisplay" class="error-display">
        <div class="error-title">3D Realm Error</div>
        <div class="error-message" id="errorMessage"></div>
        <button class="hud-button" onclick="location.reload()" style="margin-top: 15px;">Reload Page</button>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- HUD Controls -->
    <div class="hud">
        <button class="hud-button" onclick="location.href='./index.html'">‚Üê Back to Dashboard</button>
        <button class="hud-button" onclick="resetCamera()">üì∑ Reset Camera</button>
        <button class="hud-button" onclick="toggleAnimation()">‚è∏Ô∏è Pause Animation</button>
        <button class="hud-button" onclick="toggleWireframe()">üî≤ Wireframe</button>
        <button class="hud-button" onclick="focusRandomMinion()">üéØ Focus Minion</button>
    </div>

    <!-- Status Display -->
    <div class="status-display">
        <div class="status-title">üåê Realm Status</div>
        <div class="status-item">Minions Loaded: <span id="minionCount">0</span></div>
        <div class="status-item">3D Objects: <span id="objectCount">0</span></div>
        <div class="status-item">Render Mode: <span id="renderMode">Normal</span></div>
        <div class="status-item">Animation: <span id="animationStatus">Running</span></div>
        <div class="status-item">FPS: <span id="fpsCounter">0</span></div>
    </div>

    <!-- Minion Info Panel -->
    <div id="minionInfo" class="minion-info">
        <div style="font-weight: bold; margin-bottom: 10px;" id="selectedMinionName">No minion selected</div>
        <div id="selectedMinionDetails"></div>
    </div>

    <!-- Controls Help -->
    <div class="controls-help">
        <strong>Controls:</strong><br>
        üñ±Ô∏è Click & Drag: Rotate view<br>
        üîç Mouse Wheel: Zoom<br>
        üéØ Click Minion: Select & Focus<br>
        ‚å®Ô∏è WASD: Move camera
    </div>

    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        class SolarFlow3DRealm {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.minions = [];
                this.minionObjects = [];
                this.selectedMinion = null;
                this.animationPaused = false;
                this.wireframeMode = false;
                
                this.controls = {
                    mouse: { x: 0, y: 0, down: false },
                    keys: { w: false, a: false, s: false, d: false }
                };
                
                this.cameraTarget = new THREE.Vector3(0, 0, 0);
                this.cameraDistance = 20;
                this.cameraAngleY = 0;
                this.cameraAngleX = 0.3;
                
                this.frameCount = 0;
                this.lastTime = performance.now();
                this.fps = 0;
                
                this.init();
            }
            
            log(message, isError = false) {
                console.log(`[3D Realm] ${message}`);
                if (isError) {
                    this.showError(message);
                }
                this.updateLoadingProgress(message);
            }
            
            updateLoadingProgress(message) {
                const progressEl = document.getElementById('loadingProgress');
                if (progressEl) {
                    progressEl.textContent = message;
                }
            }
            
            showError(message) {
                const errorDisplay = document.getElementById('errorDisplay');
                const errorMessage = document.getElementById('errorMessage');
                if (errorDisplay && errorMessage) {
                    errorMessage.textContent = message;
                    errorDisplay.style.display = 'block';
                }
                this.hideLoading();
            }
            
            hideLoading() {
                const loadingScreen = document.getElementById('loadingScreen');
                if (loadingScreen) {
                    loadingScreen.style.display = 'none';
                }
            }
            
            async init() {
                try {
                    this.log('Checking Three.js availability...');
                    
                    if (typeof THREE === 'undefined') {
                        throw new Error('Three.js library failed to load. Check your internet connection.');
                    }
                    
                    this.log('Setting up 3D scene...');
                    this.setupScene();
                    
                    this.log('Setting up camera and renderer...');
                    this.setupCamera();
                    this.setupRenderer();
                    
                    this.log('Setting up controls...');
                    this.setupControls();
                    
                    this.log('Loading minion data...');
                    await this.loadMinionData();
                    
                    this.log('Creating 3D minions...');
                    this.createMinionObjects();
                    
                    this.log('Setting up lighting...');
                    this.setupLighting();
                    
                    this.log('Starting animation loop...');
                    this.startAnimation();
                    
                    this.log('3D Realm ready!');
                    this.hideLoading();
                    
                } catch (error) {
                    console.error('3D Realm initialization error:', error);
                    this.log(`Error: ${error.message}`, true);
                }
            }
            
            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a1a);
                
                // Add some atmospheric fog
                this.scene.fog = new THREE.Fog(0x0a0a1a, 30, 100);
                
                // Add a grid for reference
                const gridHelper = new THREE.GridHelper(50, 50, 0x404040, 0x202020);
                this.scene.add(gridHelper);
            }
            
            setupCamera() {
                const aspect = window.innerWidth / window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                this.updateCameraPosition();
            }
            
            setupRenderer() {
                const container = document.getElementById('canvas-container');
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.setClearColor(0x0a0a1a);
                
                container.appendChild(this.renderer.domElement);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            setupControls() {
                const canvas = this.renderer.domElement;
                
                // Mouse controls
                canvas.addEventListener('mousedown', (e) => {
                    this.controls.mouse.down = true;
                    this.controls.mouse.x = e.clientX;
                    this.controls.mouse.y = e.clientY;
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (this.controls.mouse.down) {
                        const deltaX = e.clientX - this.controls.mouse.x;
                        const deltaY = e.clientY - this.controls.mouse.y;
                        
                        this.cameraAngleY -= deltaX * 0.01;
                        this.cameraAngleX -= deltaY * 0.01;
                        this.cameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.cameraAngleX));
                        
                        this.controls.mouse.x = e.clientX;
                        this.controls.mouse.y = e.clientY;
                        
                        this.updateCameraPosition();
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    this.controls.mouse.down = false;
                });
                
                // Mouse wheel for zoom
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.cameraDistance += e.deltaY * 0.01;
                    this.cameraDistance = Math.max(5, Math.min(100, this.cameraDistance));
                    this.updateCameraPosition();
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'w': this.controls.keys.w = true; break;
                        case 's': this.controls.keys.s = true; break;
                        case 'a': this.controls.keys.a = true; break;
                        case 'd': this.controls.keys.d = true; break;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    switch(e.key.toLowerCase()) {
                        case 'w': this.controls.keys.w = false; break;
                        case 's': this.controls.keys.s = false; break;
                        case 'a': this.controls.keys.a = false; break;
                        case 'd': this.controls.keys.d = false; break;
                    }
                });
                
                // Click to select minions
                canvas.addEventListener('click', (e) => {
                    this.handleMinionClick(e);
                });
            }
            
            updateCameraPosition() {
                const x = Math.cos(this.cameraAngleY) * Math.cos(this.cameraAngleX) * this.cameraDistance;
                const y = Math.sin(this.cameraAngleX) * this.cameraDistance;
                const z = Math.sin(this.cameraAngleY) * Math.cos(this.cameraAngleX) * this.cameraDistance;
                
                this.camera.position.set(
                    this.cameraTarget.x + x,
                    this.cameraTarget.y + y,
                    this.cameraTarget.z + z
                );
                
                this.camera.lookAt(this.cameraTarget);
            }
            
            async loadMinionData() {
                try {
                    // Try to load from unified system first
                    if (window.UNIFIED_REAL_SYSTEM) {
                        this.minions = window.UNIFIED_REAL_SYSTEM.getMinions();
                        this.log(`Loaded ${this.minions.length} minions from unified system`);
                        return;
                    }
                    
                    // Fallback to loading from JSON files
                    const response = await fetch('./hive_state.json');
                    if (!response.ok) {
                        throw new Error(`Failed to load hive_state.json: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    if (data.minions && data.minions.roster) {
                        this.minions = data.minions.roster;
                        this.log(`Loaded ${this.minions.length} minions from hive_state.json`);
                    } else {
                        throw new Error('No minions found in hive_state.json');
                    }
                    
                } catch (error) {
                    // Create sample minions if loading fails
                    this.log(`Warning: ${error.message}. Creating sample minions.`);
                    this.createSampleMinions();
                }
            }
            
            createSampleMinions() {
                this.minions = [
                    { id: 'ATLAS', tier: 3, role: 'OVERSEER', energy_credits: 250, happiness_sim: 0.8 },
                    { id: 'LUMEN', tier: 3, role: 'OVERSEER', energy_credits: 180, happiness_sim: 0.7 },
                    { id: 'ORBIT', tier: 2, role: 'SPECIALIST', energy_credits: 160, happiness_sim: 0.6 },
                    { id: 'PRISM', tier: 2, role: 'SPECIALIST', energy_credits: 140, happiness_sim: 0.9 },
                    { id: 'BOLT', tier: 2, role: 'SPECIALIST', energy_credits: 120, happiness_sim: 0.5 }
                ];
                this.log('Created 5 sample minions for demonstration');
            }
            
            createMinionObjects() {
                const positions = this.generateMinionPositions(this.minions.length);
                
                this.minions.forEach((minion, index) => {
                    const minionObject = this.createMinionMesh(minion, positions[index]);
                    this.minionObjects.push(minionObject);
                    this.scene.add(minionObject);
                });
                
                this.updateStats();
            }
            
            generateMinionPositions(count) {
                const positions = [];
                const radius = Math.max(8, Math.sqrt(count) * 2);
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const ringRadius = radius + Math.sin(i * 0.1) * 2;
                    const height = Math.sin(i * 0.3) * 3;
                    
                    positions.push({
                        x: Math.cos(angle) * ringRadius,
                        y: height,
                        z: Math.sin(angle) * ringRadius
                    });
                }
                
                return positions;
            }
            
            createMinionMesh(minion, position) {
                const group = new THREE.Group();
                
                // Main body (cube for now, could be more complex)
                const bodyGeometry = new THREE.BoxGeometry(1, 1.5, 1);
                const bodyColor = this.getMinionColor(minion);
                const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.75;
                body.castShadow = true;
                group.add(body);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2;
                head.castShadow = true;
                group.add(head);
                
                // Eyes (simple white spheres)
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.15, 2.1, 0.35);
                group.add(leftEye);
                
                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.15, 2.1, 0.35);
                group.add(rightEye);
                
                // Position the group
                group.position.set(position.x, position.y, position.z);
                
                // Store minion data for reference
                group.userData = { minion: minion };
                
                // Add floating animation based on happiness
                group.userData.originalY = position.y;
                group.userData.animationOffset = Math.random() * Math.PI * 2;
                
                return group;
            }
            
            getMinionColor(minion) {
                // Color based on tier and role
                const tierColors = {
                    1: 0x666666, // Gray
                    2: 0x4169E1, // Royal Blue
                    3: 0x00FF7F, // Spring Green
                    4: 0xFFD700, // Gold
                    5: 0xFF69B4  // Hot Pink
                };
                
                return tierColors[minion.tier] || 0x888888;
            }
            
            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                // Directional light (sun)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);
                
                // Point lights for atmosphere
                const pointLight1 = new THREE.PointLight(0x00ffff, 0.5, 30);
                pointLight1.position.set(10, 10, 10);
                this.scene.add(pointLight1);
                
                const pointLight2 = new THREE.PointLight(0xff00ff, 0.5, 30);
                pointLight2.position.set(-10, 10, -10);
                this.scene.add(pointLight2);
            }
            
            startAnimation() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    if (!this.animationPaused) {
                        this.updateAnimation();
                        this.handleKeyboardMovement();
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                    this.updateFPS();
                };
                
                animate();
            }
            
            updateAnimation() {
                const time = performance.now() * 0.001; // Convert to seconds
                
                // Animate minions
                this.minionObjects.forEach(minionObj => {
                    const minion = minionObj.userData.minion;
                    const happiness = minion.happiness_sim || 0.5;
                    
                    // Floating animation based on happiness
                    const floatAmount = happiness * 2 + 0.5;
                    const floatSpeed = happiness * 2 + 1;
                    minionObj.position.y = minionObj.userData.originalY + 
                        Math.sin(time * floatSpeed + minionObj.userData.animationOffset) * floatAmount;
                    
                    // Rotation based on activity
                    if (minion.mode === 'COLLAB' || minion.mode === 'FOCUS') {
                        minionObj.rotation.y += 0.01;
                    }
                });
            }
            
            handleKeyboardMovement() {
                const moveSpeed = 0.5;
                
                if (this.controls.keys.w) {
                    this.cameraTarget.z -= moveSpeed;
                }
                if (this.controls.keys.s) {
                    this.cameraTarget.z += moveSpeed;
                }
                if (this.controls.keys.a) {
                    this.cameraTarget.x -= moveSpeed;
                }
                if (this.controls.keys.d) {
                    this.cameraTarget.x += moveSpeed;
                }
                
                if (this.controls.keys.w || this.controls.keys.s || this.controls.keys.a || this.controls.keys.d) {
                    this.updateCameraPosition();
                }
            }
            
            handleMinionClick(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                
                const intersects = raycaster.intersectObjects(this.minionObjects, true);
                
                if (intersects.length > 0) {
                    // Find the top-level minion object
                    let minionObject = intersects[0].object;
                    while (minionObject.parent && !minionObject.userData.minion) {
                        minionObject = minionObject.parent;
                    }
                    
                    if (minionObject.userData.minion) {
                        this.selectMinion(minionObject);
                    }
                }
            }
            
            selectMinion(minionObject) {
                const minion = minionObject.userData.minion;
                this.selectedMinion = minionObject;
                
                // Focus camera on selected minion
                this.cameraTarget.copy(minionObject.position);
                this.updateCameraPosition();
                
                // Show minion info
                this.showMinionInfo(minion);
                
                // Add selection indicator (glow effect)
                this.addSelectionGlow(minionObject);
            }
            
            showMinionInfo(minion) {
                const infoPanel = document.getElementById('minionInfo');
                const nameEl = document.getElementById('selectedMinionName');
                const detailsEl = document.getElementById('selectedMinionDetails');
                
                nameEl.textContent = minion.id;
                detailsEl.innerHTML = `
                    <strong>Role:</strong> ${minion.role || 'Worker'}<br>
                    <strong>Tier:</strong> ${minion.tier || 1}<br>
                    <strong>Credits:</strong> ${(minion.energy_credits || 0).toLocaleString()}<br>
                    <strong>Happiness:</strong> ${Math.floor((minion.happiness_sim || 0.5) * 100)}%<br>
                    <strong>Mode:</strong> ${minion.mode || 'IDLE'}
                `;
                
                infoPanel.style.display = 'block';
                
                // Hide after 5 seconds
                setTimeout(() => {
                    if (infoPanel.style.display !== 'none') {
                        infoPanel.style.display = 'none';
                    }
                }, 5000);
            }
            
            addSelectionGlow(minionObject) {
                // Remove previous selection glow
                this.scene.children.forEach(child => {
                    if (child.name === 'selectionGlow') {
                        this.scene.remove(child);
                    }
                });
                
                // Add new selection glow
                const glowGeometry = new THREE.RingGeometry(2, 2.5, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff, 
                    transparent: true, 
                    opacity: 0.6,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(minionObject.position);
                glow.position.y = 0.1;
                glow.rotation.x = -Math.PI / 2;
                glow.name = 'selectionGlow';
                this.scene.add(glow);
            }
            
            updateFPS() {
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastTime >= 1000) {
                    this.fps = Math.round(this.frameCount * 1000 / (now - this.lastTime));
                    this.frameCount = 0;
                    this.lastTime = now;
                    
                    const fpsEl = document.getElementById('fpsCounter');
                    if (fpsEl) {
                        fpsEl.textContent = this.fps;
                    }
                }
            }
            
            updateStats() {
                document.getElementById('minionCount').textContent = this.minions.length;
                document.getElementById('objectCount').textContent = this.scene.children.length;
            }
            
            // Control functions for HUD buttons
            resetCamera() {
                this.cameraTarget.set(0, 0, 0);
                this.cameraDistance = 20;
                this.cameraAngleY = 0;
                this.cameraAngleX = 0.3;
                this.updateCameraPosition();
            }
            
            toggleAnimation() {
                this.animationPaused = !this.animationPaused;
                document.getElementById('animationStatus').textContent = this.animationPaused ? 'Paused' : 'Running';
            }
            
            toggleWireframe() {
                this.wire            toggleWireframe() {
                this.wireframeMode = !this.wireframeMode;
                
                this.minionObjects.forEach(minionObj => {
                    minionObj.children.forEach(child => {
                        if (child.material) {
                            child.material.wireframe = this.wireframeMode;
                        }
                    });
                });
                
                document.getElementById('renderMode').textContent = this.wireframeMode ? 'Wireframe' : 'Normal';
            }
            
            focusRandomMinion() {
                if (this.minionObjects.length === 0) return;
                
                const randomMinion = this.minionObjects[Math.floor(Math.random() * this.minionObjects.length)];
                this.selectMinion(randomMinion);
            }
        }

        // Global control functions for HUD
        let realmInstance = null;

        window.resetCamera = () => {
            if (realmInstance) realmInstance.resetCamera();
        };

        window.toggleAnimation = () => {
            if (realmInstance) realmInstance.toggleAnimation();
        };

        window.toggleWireframe = () => {
            if (realmInstance) realmInstance.toggleWireframe();
        };

        window.focusRandomMinion = () => {
            if (realmInstance) realmInstance.focusRandomMinion();
        };

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('3D Realm Error:', e);
            const errorDisplay = document.getElementById('errorDisplay');
            const errorMessage = document.getElementById('errorMessage');
            if (errorDisplay && errorMessage) {
                errorMessage.textContent = `JavaScript Error: ${e.message}\n\nStack: ${e.error?.stack || 'No stack trace'}`;
                errorDisplay.style.display = 'block';
            }
        });

        // Initialize the 3D realm when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üåê Initializing 3D SolarFlow Realm...');
            
            // Small delay to ensure all resources are loaded
            setTimeout(() => {
                try {
                    realmInstance = new SolarFlow3DRealm();
                } catch (error) {
                    console.error('Failed to initialize 3D realm:', error);
                    const errorDisplay = document.getElementById('errorDisplay');
                    const errorMessage = document.getElementById('errorMessage');
                    if (errorDisplay && errorMessage) {
                        errorMessage.textContent = `Initialization Error: ${error.message}\n\nThis usually means Three.js failed to load or your browser doesn't support WebGL.`;
                        errorDisplay.style.display = 'block';
                    }
                }
            }, 1000);
        });
    </script>
</body>
</html>