<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Realm - SolarFlow Minions</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #0a0a0a; 
            color: #ffffff; 
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #00ff00;
            z-index: 1000;
        }
        
        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #00ff00;
            color: #ffffff;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background: rgba(0, 255, 0, 0.4);
            box-shadow: 0 0 10px #00ff00;
        }
        
        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            display: none;
        }
        
        #canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            color: #ffffff;
            padding: 20px;
            border-radius: 10px;
            max-width: 80vw;
            text-align: center;
            z-index: 1000;
        }
        
        .status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="loading">Initializing 3D Realm...</div>
    
    <div id="hud" style="display: none;">
        <button class="btn" onclick="location.href='index.html'">← Back</button>
        <button class="btn" onclick="resetCamera()">Reset Camera</button>
        <button class="btn" onclick="toggleWireframe()">Toggle Wireframe</button>
        <button class="btn" onclick="focusAtlas()">Focus ATLAS</button>
        <button class="btn" onclick="showMinions()">Show All Minions</button>
    </div>
    
    <div class="status" id="status">Loading...</div>
    
    <div id="info">
        <h3 id="minion-name">Minion</h3>
        <p id="minion-details">Click on a minion to see details</p>
        <div id="minion-stats"></div>
    </div>
    
    <canvas id="canvas"></canvas>

    <!-- Use CDN that actually works -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let minionData = []; // Real minion data from hive_state.json
        let minionMeshes = [];
        let isWireframe = false;
        let selectedMinion = null;

        // Simple orbit controls (simplified version)
        class SimpleOrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3();
                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();
                this.scale = 1;
                this.panOffset = new THREE.Vector3();
                this.zoomChanged = false;
                
                this.rotateSpeed = 1.0;
                this.zoomSpeed = 1.2;
                this.panSpeed = 1.0;
                
                this.minDistance = 0;
                this.maxDistance = Infinity;
                
                this.enableDamping = true;
                this.dampingFactor = 0.05;
                
                this.domElement.addEventListener('contextmenu', this.onContextMenu.bind(this));
                this.domElement.addEventListener('mousedown', this.onMouseDown.bind(this));
                this.domElement.addEventListener('wheel', this.onMouseWheel.bind(this));
                
                this.update();
            }
            
            update() {
                const offset = new THREE.Vector3();
                offset.copy(this.camera.position).sub(this.target);
                
                this.spherical.setFromVector3(offset);
                
                if (this.enableDamping) {
                    this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;
                    this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;
                } else {
                    this.spherical.theta += this.sphericalDelta.theta;
                    this.spherical.phi += this.sphericalDelta.phi;
                }
                
                this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));
                this.spherical.radius *= this.scale;
                this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
                
                offset.setFromSpherical(this.spherical);
                this.camera.position.copy(this.target).add(offset);
                this.camera.lookAt(this.target);
                
                if (this.enableDamping) {
                    this.sphericalDelta.theta *= (1 - this.dampingFactor);
                    this.sphericalDelta.phi *= (1 - this.dampingFactor);
                } else {
                    this.sphericalDelta.set(0, 0, 0);
                }
                
                this.scale = 1;
                
                return false;
            }
            
            onMouseDown(event) {
                if (event.button === 0) {
                    this.rotateStart = new THREE.Vector2(event.clientX, event.clientY);
                    document.addEventListener('mousemove', this.onMouseMove.bind(this));
                    document.addEventListener('mouseup', this.onMouseUp.bind(this));
                }
            }
            
            onMouseMove(event) {
                const rotateEnd = new THREE.Vector2(event.clientX, event.clientY);
                const rotateDelta = new THREE.Vector2();
                rotateDelta.subVectors(rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
                
                this.sphericalDelta.theta -= 2 * Math.PI * rotateDelta.x / this.domElement.clientHeight;
                this.sphericalDelta.phi -= 2 * Math.PI * rotateDelta.y / this.domElement.clientHeight;
                
                this.rotateStart.copy(rotateEnd);
            }
            
            onMouseUp() {
                document.removeEventListener('mousemove', this.onMouseMove.bind(this));
                document.removeEventListener('mouseup', this.onMouseUp.bind(this));
            }
            
            onMouseWheel(event) {
                if (event.deltaY < 0) {
                    this.scale /= this.zoomSpeed;
                } else if (event.deltaY > 0) {
                    this.scale *= this.zoomSpeed;
                }
            }
            
            onContextMenu(event) {
                event.preventDefault();
            }
        }

        // Initialize the 3D scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 50, 200);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 50);

            // Renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Controls
            controls = new SimpleOrbitControls(camera, renderer.domElement);
            controls.minDistance = 5;
            controls.maxDistance = 100;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0x00ff00, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x00ffff, 0.8, 100);
            pointLight.position.set(0, 30, 0);
            scene.add(pointLight);

            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x1a1a1a,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Grid
            const gridHelper = new THREE.GridHelper(200, 20, 0x00ff00, 0x004400);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Load minion data
            loadMinions();

            // Start animation
            animate();

            // Show HUD
            document.getElementById('loading').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';
            document.getElementById('status').textContent = 'Realm Online';
        }

        // Load minion data
        async function loadMinions() {
            try {
                // Try to load from hive_state.json
                let response = await fetch('hive_state.json?' + Date.now());
                let data;
                
                if (response.ok) {
                    data = await response.json();
                    minionData = data.minions?.roster || [];
                } else {
                    // Fallback to minions.json
                    response = await fetch('minions.json?' + Date.now());
                    if (response.ok) {
                        data = await response.json();
                        minionData = data.minions || [];
                    } else {
                        throw new Error('Could not load minion data');
                    }
                }

                if (minionData.length === 0) {
                    throw new Error('No minions found in data');
                }

                createMinionMeshes();
                document.getElementById('status').textContent = `${minionData.length} Minions Loaded`;
                
            } catch (error) {
                console.error('Error loading minions:', error);
                createFallbackMinions();
                document.getElementById('status').textContent = 'Using Fallback Data';
            }
        }

        // Create fallback minions if data loading fails - use existing format from hive_state.json
        function createFallbackMinions() {
            // Load fallback data that matches hive_state.json structure instead of creating new arrays
            console.warn('Using emergency fallback - actual minion data should be loaded from hive_state.json');
            minionData = [
                { id: 'ATLAS', tier: 'Alpha', role: 'Orchestrator', happiness_sim: 85, energy_credits: 1200 },
                { id: 'LUMEN', tier: 'Beta', role: 'Analyzer', happiness_sim: 72, energy_credits: 890 },
                { id: 'ORBIT', tier: 'Gamma', role: 'Monitor', happiness_sim: 65, energy_credits: 650 },
                { id: 'PRISM', tier: 'Beta', role: 'Processor', happiness_sim: 78, energy_credits: 920 },
                { id: 'BOLT', tier: 'Alpha', role: 'Executor', happiness_sim: 90, energy_credits: 1100 }
            ];
            createMinionMeshes();
        }

        // Create 3D meshes for minions using real data from hive_state.json
        function createMinionMeshes() {
            minionMeshes = [];
            const radius = 25;
            const count = minionData.length;

            minionData.forEach((minion, index) => {
                // Position in circle
                const angle = (index / count) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = 2;

                // Create minion mesh
                const geometry = new THREE.CapsuleGeometry(1, 2, 4, 8);
                
                // Color based on tier
                let color = 0x00ff00; // default green
                if (minion.tier === 'Alpha') color = 0xff0000; // red
                else if (minion.tier === 'Beta') color = 0x0000ff; // blue
                else if (minion.tier === 'Gamma') color = 0xffff00; // yellow

                const material = new THREE.MeshLambertMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.userData = { minion: minion, originalColor: color };

                // Add floating animation
                mesh.userData.animationOffset = Math.random() * Math.PI * 2;

                scene.add(mesh);
                minionMeshes.push(mesh);

                // Add label
                createLabel(minion.id, x, y + 3, z);

                // Add glow effect
                const glowGeometry = new THREE.CapsuleGeometry(1.2, 2.2, 4, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(mesh.position);
                scene.add(glow);
                mesh.userData.glow = glow;
            });

            // Place ATLAS at center if it exists
            const atlasMinion = minionMeshes.find(m => m.userData.minion.id === 'ATLAS');
            if (atlasMinion) {
                atlasMinion.position.set(0, 5, 0);
                if (atlasMinion.userData.glow) {
                    atlasMinion.userData.glow.position.copy(atlasMinion.position);
                }
            }
        }

        // Create text labels
        function createLabel(text, x, y, z) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = '#00ff00';
            context.font = '20px Courier New';
            context.textAlign = 'center';
            context.fillText(text, canvas.width / 2, canvas.height / 2 + 5);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.set(x, y, z);
            sprite.scale.set(8, 2, 1);
            scene.add(sprite);
        }

        // Handle mouse clicks on minions
        function onMouseClick(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(minionMeshes);
            
            if (intersects.length > 0) {
                const minion = intersects[0].object.userData.minion;
                selectMinion(minion, intersects[0].object);
            } else {
                hideInfo();
            }
        }

        // Select and show minion info
        function selectMinion(minion, mesh) {
            selectedMinion = { minion, mesh };
            
            // Reset all minion colors
            minionMeshes.forEach(m => {
                m.material.color.setHex(m.userData.originalColor);
                m.material.opacity = 0.8;
                if (m.userData.glow) {
                    m.userData.glow.material.opacity = 0.3;
                }
            });
            
            // Highlight selected minion
            mesh.material.color.setHex(0xffffff);
            mesh.material.opacity = 1.0;
            if (mesh.userData.glow) {
                mesh.userData.glow.material.opacity = 0.6;
            }
            
            // Show info panel
            document.getElementById('minion-name').textContent = minion.id;
            document.getElementById('minion-details').textContent = 
                `Tier: ${minion.tier || 'Unknown'} | Role: ${minion.role || 'Unknown'}`;
            document.getElementById('minion-stats').innerHTML = 
                `<div>Happiness: ${minion.happiness_sim || 50}%</div>
                 <div>Credits: ${minion.energy_credits || 0}</div>
                 <div>Reputation: ${minion.reputation || 0.5}</div>`;
            document.getElementById('info').style.display = 'block';
        }

        // Hide info panel
        function hideInfo() {
            selectedMinion = null;
            document.getElementById('info').style.display = 'none';
            
            // Reset all colors
            minionMeshes.forEach(m => {
                m.material.color.setHex(m.userData.originalColor);
                m.material.opacity = 0.8;
                if (m.userData.glow) {
                    m.userData.glow.material.opacity = 0.3;
                }
            });
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls
            controls.update();
            
            // Animate minions (floating effect)
            const time = Date.now() * 0.001;
            minionMeshes.forEach(mesh => {
                const offset = mesh.userData.animationOffset || 0;
                mesh.position.y = mesh.position.y + Math.sin(time * 2 + offset) * 0.01;
                mesh.rotation.y = time * 0.5 + offset;
                
                if (mesh.userData.glow) {
                    mesh.userData.glow.position.copy(mesh.position);
                    mesh.userData.glow.rotation.copy(mesh.rotation);
                }
            });
            
            renderer.render(scene, camera);
        }

        // UI Functions
        function resetCamera() {
            camera.position.set(0, 20, 50);
            controls.target.set(0, 0, 0);
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            minionMeshes.forEach(mesh => {
                mesh.material.wireframe = isWireframe;
            });
        }

        function focusAtlas() {
            const atlasMinion = minionMeshes.find(m => m.userData.minion.id === 'ATLAS');
            if (atlasMinion) {
                controls.target.copy(atlasMinion.position);
                camera.position.set(
                    atlasMinion.position.x + 10,
                    atlasMinion.position.y + 10,
                    atlasMinion.position.z + 10
                );
            }
        }

        function showMinions() {
            const minionList = minionData.map(m => `${m.id} (${m.tier})`).join(', ');
            alert(`Loaded Minions: ${minionList}`);
        }

        // Event listeners
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('click', onMouseClick);

        // Error handling
        window.addEventListener('error', (error) => {
            console.error('3D Realm Error:', error);
            document.body.innerHTML += `
                <div class="error">
                    <h3>3D Realm Error</h3>
                    <p>Error: ${error.message}</p>
                    <p>Please refresh the page or check console for details.</p>
                    <button onclick="location.reload()" class="btn">Reload</button>
                </div>
            `;
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            try {
                init();
            } catch (error) {
                console.error('Initialization error:', error);
                document.body.innerHTML = `
                    <div class="error">
                        <h3>Failed to Initialize 3D Realm</h3>
                        <p>Your browser may not support WebGL or Three.js.</p>
                        <p>Error: ${error.message}</p>
                        <button onclick="location.href='index.html'" class="btn">← Back to Main</button>
                    </div>
                `;
            }
        });
    </script>
</body>
</html>