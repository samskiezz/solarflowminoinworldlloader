import { io } from "socket.io-client";
import { getAccessToken } from "./auth-utils.js";
function initializeSocket(config, handlers) {
    var _a;
    const socket = io(config.serverUrl, {
        path: config.mountPath,
        transports: config.transports,
        query: {
            app_id: config.appId,
            token: (_a = config.token) !== null && _a !== void 0 ? _a : getAccessToken(),
        },
    });
    socket.on("connect", async () => {
        var _a;
        console.log("connect", socket.id);
        return (_a = handlers.connect) === null || _a === void 0 ? void 0 : _a.call(handlers);
    });
    socket.on("update_model", async (msg) => {
        var _a;
        return (_a = handlers.update_model) === null || _a === void 0 ? void 0 : _a.call(handlers, msg);
    });
    socket.on("error", async (error) => {
        var _a;
        return (_a = handlers.error) === null || _a === void 0 ? void 0 : _a.call(handlers, error);
    });
    socket.on("connect_error", async (error) => {
        var _a;
        console.error("connect_error", error);
        return (_a = handlers.error) === null || _a === void 0 ? void 0 : _a.call(handlers, error);
    });
    return socket;
}
export function RoomsSocket({ config }) {
    let currentConfig = { ...config };
    const roomsToListeners = {};
    const handlers = {
        connect: async () => {
            const promises = [];
            Object.keys(roomsToListeners).forEach((room) => {
                joinRoom(room);
                const listeners = getListeners(room);
                listeners === null || listeners === void 0 ? void 0 : listeners.forEach(({ connect }) => {
                    const promise = async () => connect === null || connect === void 0 ? void 0 : connect();
                    promises.push(promise());
                });
            });
            await Promise.all(promises);
        },
        update_model: async (msg) => {
            const listeners = getListeners(msg.room);
            const promises = listeners.map((listener) => { var _a; return (_a = listener.update_model) === null || _a === void 0 ? void 0 : _a.call(listener, msg); });
            await Promise.all(promises);
        },
        error: async (error) => {
            console.error("error", error);
            const promises = Object.values(roomsToListeners)
                .flat()
                .map((listener) => { var _a; return (_a = listener.error) === null || _a === void 0 ? void 0 : _a.call(listener, error); });
            await Promise.all(promises);
        },
    };
    let socket = initializeSocket(config, handlers);
    function cleanup() {
        disconnect();
    }
    function disconnect() {
        if (socket) {
            socket.disconnect();
        }
    }
    function updateConfig(config) {
        cleanup();
        currentConfig = {
            ...currentConfig,
            ...config,
        };
        socket = initializeSocket(currentConfig, handlers);
    }
    function joinRoom(room) {
        socket.emit("join", room);
    }
    function leaveRoom(room) {
        socket.emit("leave", room);
    }
    async function updateModel(room, data) {
        var _a;
        const dataStr = JSON.stringify(data);
        return (_a = handlers.update_model) === null || _a === void 0 ? void 0 : _a.call(handlers, { room, data: dataStr });
    }
    function getListeners(room) {
        return roomsToListeners[room];
    }
    const subscribeToRoom = (room, handlers) => {
        if (!roomsToListeners[room]) {
            joinRoom(room);
            roomsToListeners[room] = [];
        }
        roomsToListeners[room].push(handlers);
        return () => {
            var _a, _b;
            roomsToListeners[room] =
                (_b = (_a = roomsToListeners[room]) === null || _a === void 0 ? void 0 : _a.filter((listener) => listener !== handlers)) !== null && _b !== void 0 ? _b : [];
            if (roomsToListeners[room].length === 0) {
                leaveRoom(room);
            }
        };
    };
    return {
        socket,
        subscribeToRoom,
        updateConfig,
        updateModel,
        disconnect,
    };
}
